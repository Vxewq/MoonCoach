import {
  __publicField
} from "./chunk-WXXH56N5.js";

// ../node_modules/material/src/module/css.js
var has = (element, className) => {
  if (!element || !className)
    return false;
  return !!element.className.match(new RegExp(`(\\s|^)${className}(\\s|$)`));
};
var add = (element, className) => {
  if (!element || !className)
    return;
  const sanitizedClassName = className.trim().replace(/\s+/g, " ");
  const classNames = sanitizedClassName.split(" ");
  for (const cn of classNames) {
    if (!has(element, cn)) {
      element.classList.add(cn);
    }
  }
  return element;
};
var remove = (element, className) => {
  if (!element || !className)
    return;
  element.classList.remove(className);
  return element;
};

// ../node_modules/material/src/module/dataset.js
var dataset = (element, data) => {
  if (data) {
    Object.entries(data).forEach(([key, value]) => {
      element.dataset[key] = value;
    });
  }
};
var dataset_default = dataset;

// ../node_modules/material/src/module/object.js
var is = (object) => {
  return object && typeof object === "object" && Object.getPrototypeOf(object) === Object.getPrototypeOf({});
};

// ../node_modules/material/src/module/layout.js
function create(schema, container, structure = {}, level = 0, components = []) {
  level++;
  let component;
  const object = {};
  const fragment = document.createDocumentFragment();
  if (!Array.isArray(schema)) {
    console.trace("Schema is not an array!");
  }
  for (let i = 0; i < schema.length; i++) {
    var name;
    let options2 = {};
    if (schema[i] instanceof Object && typeof schema[i] === "function") {
      if (is(schema[i + 1])) {
        options2 = schema[i + 1];
      } else if (is(schema[i + 2])) {
        options2 = schema[i + 2];
      }
      if (typeof schema[i + 1] === "string") {
        name = schema[i + 1];
        if (!schema[i].isElement && !schema[i].isComponent) {
          options2.name = name;
        }
      }
      component = new schema[i](options2);
      const element = component.element || component;
      if (level === 1)
        structure.element = element;
      if (name) {
        structure[name] = component;
        components.push([name, component]);
      }
      if (component) {
        if (component.insert)
          component.insert(fragment);
        else
          fragment.appendChild(element);
        if (container) {
          component._container = container;
          if (component.onInserted)
            component.onInserted(container);
        }
      }
    } else if (Array.isArray(schema[i])) {
      if (!component)
        component = container;
      create(schema[i], component, structure, level, components);
    }
  }
  if (container && fragment.hasChildNodes()) {
    const wrapper = container.element || container;
    wrapper.appendChild(fragment);
  }
  function get3(name2) {
    return structure[name2] || null;
  }
  object.component = structure;
  object.components = components;
  object.get = get3;
  return object;
}

// ../node_modules/material/src/module/build.js
var build = (instance2) => {
  const { tag = "div", class: customClass, data, base, container, underlay, layout, icon: icon3, label, show: show2 } = instance2.options;
  const { defaults: defaults2 = {} } = instance2.constructor;
  instance2.element = document.createElement(tag);
  if (defaults2.base)
    add(instance2.element, defaults2.base);
  if (defaults2.class)
    add(instance2.element, defaults2.class);
  if (customClass !== defaults2.class) {
    add(instance2.element, customClass);
  }
  if (data) {
    dataset_default(instance2.element, data);
  }
  setupContainer(instance2, base, container);
  if (layout) {
    setupLayout(instance2, layout);
  }
  instance2.ui = instance2.ui || {};
  if (instance2.options.underlay)
    buildUnderlay(instance2, defaults2.class);
  if (icon3 && !instance2.ui.icon)
    buildIcon(instance2);
  if (label && !instance2.ui.label)
    buildLabel(instance2);
  if (show2 === true && instance2.show)
    instance2.show();
};
var setupContainer = (instance2, base, container) => {
  instance2.container = base === "view" || base === "app" ? container || document.body : container;
  if (instance2.container)
    instance2.container.appendChild(instance2.element);
};
var setupLayout = (instance2, layout) => {
  instance2.layout = create(layout, instance2.element);
  instance2.ui = instance2.layout.component;
};
function buildUnderlay(instance2, name) {
  if (instance2.options.underlay) {
    instance2.underlay = document.createElement("div");
    instance2.underlay.classList.add(name + "-underlay");
    instance2.options.container.appendChild(instance2.underlay);
  }
}
function buildLabel({ ui, options: options2, element }) {
  const { label } = options2;
  if (!label)
    return;
  ui.label = document.createElement("label");
  ui.label.classList.add("label");
  ui.label.innerHTML = label;
  element.appendChild(ui.label);
}
function buildIcon({ ui, options: options2, element }) {
  const { icon: icon3 } = options2;
  if (!icon3)
    return;
  ui.icon = document.createElement("i");
  ui.icon.classList.add("icon");
  ui.icon.innerHTML = icon3;
  element.appendChild(ui.icon);
}
var build_default = build;

// ../node_modules/material/src/module/dom.js
function append(container, element) {
  console.log(container, element);
  container.appendChild(element);
  return element;
}
function prepend(container, element) {
  return container.insertBefore(element, container.firstChild);
}
function after(container, element) {
  return container.parentNode.insertBefore(element, container.nextSibling);
}
function before(container, element) {
  return container.insertBefore(element, container);
}
function replace(container, element) {
  return container.parentNode.replaceChild(element, container);
}
function remove2(element) {
  const parent = element.parentNode;
  return parent.removeChild(element);
}
function dispose(element) {
  const el = element;
  return el.parentNode ? el.parentNode.removeChild(el) : el;
}
function empty(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}
function destroy(element) {
  if (element && element.parentNode) {
    return element.parentNode.removeChild(element);
  } else {
    return null;
  }
}
var dom_default = { append, prepend, after, before, replace, remove: remove2, destroy, empty, dispose };

// ../node_modules/material/src/class/component.js
var Component = class {
  constructor(options2) {
    this.options = { ...this.constructor.defaults, ...options2 };
    const mixins = this.options.mixins || [];
    for (let i = 0; i < mixins.length; i++) {
      Object.assign(this, mixins[i]);
    }
    build_default(this);
  }
  destroy() {
    console.log("dest5roy");
    if (this.options.transition && this.element) {
      this.element.classList.remove("show");
      if (this.underlay) {
        this.underlay.classList.remove("show");
      }
      setTimeout(() => {
        dom_default.destroy(this.element);
        if (this.underlay)
          dom_default.destroy(this.underlay);
      }, this.options.transition);
    } else {
      dom_default.destroy(this.element);
      if (this.underlay)
        dom_default.destroy(this.underlay);
    }
  }
};
__publicField(Component, "base", "component");
var component_default = Component;

// ../node_modules/material/src/module/extract.js
function e(instance2, ev) {
  if (!ev)
    return instance2;
  else if (!ev.match(/\./)) {
    return {
      element: instance2,
      name: ev
    };
  }
  let iteration;
  const obj = {};
  let element;
  const keys = ev.split(".");
  if (keys[0] === "window") {
    element = window;
  } else {
    for (let i = 0, l = keys.length; i <= l; i++) {
      const key = keys[i];
      iteration = iteration || instance2;
      iteration = iteration[key];
      if (i === keys.length - 2) {
        element = iteration;
      }
    }
  }
  obj.element = element;
  obj.name = keys[keys.length - 1];
  return obj;
}
function f(instance2, func) {
  if (!func)
    return;
  if (typeof func === "function") {
    return func;
  } else if (!func.match(/\./))
    return instance2[func];
  let iteration;
  const keys = func.split(".");
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i];
    iteration = iteration || instance2;
    iteration = iteration[key];
  }
  return iteration;
}
var extract_default = { e, f };

// ../node_modules/material/src/module/last.js
var last = (str, that) => {
  if (!str)
    return that;
  if (!str.includes("."))
    return that[str];
  return str.split(".").reduce((acc, key) => acc[key], that);
};
var last_default = last;

// ../node_modules/material/src/module/events.js
var events = {
  eventHandlers: {},
  // Use an array to store events and handlers
  attach(eventsArray, context) {
    if (!eventsArray)
      return;
    const uid = context._uid || (context._uid = context.options.class + Math.random().toString(36).substr(2, 9));
    this.eventHandlers[uid] = this.eventHandlers[uid] || {};
    eventsArray.forEach(([eventDef, funcDef, option]) => {
      var _a, _b;
      const e2 = extract_default.e(context, eventDef);
      const isFunction = typeof funcDef === "function";
      let f2 = null;
      let keys = [];
      if (!isFunction) {
        f2 = extract_default.f(context, funcDef);
        keys = funcDef.split(".");
        keys.pop();
      }
      const bound = last_default(keys.join("."), context);
      let handler = null;
      if (isFunction) {
        handler = funcDef.bind(context);
      } else if (f2 && bound) {
        handler = f2.bind(bound);
      } else {
        return;
      }
      let isPassive = false;
      if (e2.name === "touchstart" || e2.name === "touchmove") {
        isPassive = true;
        option = { ...option, passive: true };
      }
      if (!this.eventHandlers[uid][eventDef]) {
        if (handler && e2 && ((_a = e2.element) == null ? void 0 : _a.addEventListener)) {
          e2.element.addEventListener(e2.name, handler, isPassive ? { passive: true } : option);
          this.eventHandlers[uid][eventDef] = handler;
        } else if (e2 && ((_b = e2.element) == null ? void 0 : _b.on) && handler) {
          e2.element.on(e2.name, handler);
          this.eventHandlers[uid][eventDef] = handler;
        }
      }
    });
    return this;
  },
  detach(eventsArray, context) {
    const uid = context._uid;
    if (!this.eventHandlers[uid])
      return;
    eventsArray.forEach(
      ([eventDef, funcDef, option]) => {
        const e2 = extract_default.e(context, eventDef);
        const handler = this.eventHandlers[uid][eventDef];
        if (handler) {
          e2.element.removeEventListener(e2.name, handler);
        } else if (e2.element.off) {
          e2.element.off(e2.name, handler);
        }
        delete this.eventHandlers[uid][eventDef];
      }
    );
  },
  list(context) {
    const uid = context == null ? void 0 : context._uid;
    return uid ? this.eventHandlers[uid] || {} : this.eventHandlers;
  }
};
var events_default = events;

// ../node_modules/material/src/class/control.js
var Control = class extends component_default {
  constructor(options2) {
    super(options2);
    this.events = {};
    if (this.options.events) {
      events_default.attach(this.options.events, this);
    }
  }
  on(event, listener) {
    var _a;
    (_a = this.events)[event] ?? (_a[event] = []);
    this.events[event].push(listener);
    return this;
  }
  emit(event, ...args) {
    var _a, _b;
    (_b = (_a = this.events) == null ? void 0 : _a[event]) == null ? void 0 : _b.forEach((listener) => listener.apply(this, args));
    return this;
  }
  destroy() {
    var _a;
    super.destroy();
    (_a = this.emit) == null ? void 0 : _a.call(this, "destroy");
  }
};
__publicField(Control, "base", "control");
var control_default = Control;

// ../node_modules/material/src/mixin/build.js
var build_default2 = {
  build() {
    this.element = document.createElement(this.options.tag || "div");
    const defaults2 = this.constructor.defaults || {};
    if (defaults2.base)
      add(this.element, defaults2.base);
    if (defaults2.class)
      add(this.element, defaults2.class);
    if (this.options.class !== defaults2.class) {
      add(this.element, this.options.class);
    }
    if (this.options.data) {
      dataset_default(this.element, this.options.data);
    }
    if (this.options.base === "view" || this.options.base === "app") {
      this.container = this.options.container || document.body;
    } else {
      this.container = this.options.container;
    }
    if (this.container)
      this.appendTo(this.container);
    if (this.options.layout) {
      this.layout = create(this.options.layout, this.element);
      this.ui = this.layout.component;
    }
    this.ui = this.ui || {};
    if (this.options.icon)
      this.buildIcon();
    if (this.options.label)
      this.buildLabel();
    if (this.options.show === true && this.show)
      this.show();
  },
  buildLabel() {
    if (!this.options.label)
      return;
    this.ui.label = document.createElement("label");
    this.ui.label.classList.add("label");
    this.ui.label.innerHTML = this.options.label;
    this.element.appendChild(this.ui.label);
  },
  buildIcon() {
    if (!this.options.icon)
      return;
    this.ui.icon = document.createElement("i");
    this.ui.icon.classList.add("icon");
    this.ui.icon.innerHTML = this.options.icon;
    this.element.appendChild(this.ui.icon);
  },
  appendTo(container) {
    container.appendChild(this.element);
  }
};

// ../node_modules/material/src/appbar.js
var _AppBar = class _AppBar {
  constructor(options2) {
    this.init(options2);
    this.build();
  }
  init(options2) {
    this.options = { ..._AppBar.defaults, ...options2 };
    Object.assign(this, build_default2);
  }
};
__publicField(_AppBar, "defaults", {
  class: "appbar"
});
var AppBar = _AppBar;
var appbar_default = AppBar;

// ../node_modules/material/src/button.js
var DEFAULT_TYPE = "button";
var DEFAULT_CLASS = "button";
var Button = class extends control_default {
  static isComponent() {
    return true;
  }
  constructor(options2) {
    super(options2);
    this.setup();
  }
  setup() {
    this.setAttributes();
    this.styleAttributes();
    if (this.options.text) {
      this.element.innerHTML = this.element.innerHTML + this.options.text;
    }
  }
  setAttributes() {
    const { type: type2, name, value, title, text, label, tooltip, data, case: caseOption } = this.options;
    this.element.setAttribute("type", type2 ?? DEFAULT_TYPE);
    if (name)
      this.element.setAttribute("name", name);
    if (value)
      this.element.setAttribute("value", value);
    if (title)
      this.element.setAttribute("title", title);
    this.element.setAttribute("aria-label", text ?? label ?? DEFAULT_CLASS);
    if (tooltip)
      this.element.setAttribute("data-tooltip", tooltip);
    if (data)
      dataset_default(this.element, data);
    if (caseOption)
      this.element.classList.add(`${caseOption}-case`);
    if (this.options.ripple)
      ripple_default(this.element);
    if (this.options.disabled)
      this.disable();
  }
  styleAttributes() {
    const { style, size, color, bold } = this.options;
    if (style)
      this.element.classList.add(`style-${style}`);
    if (size)
      this.element.classList.add(`${size}-size`);
    if (color)
      this.element.classList.add(`color-${color}`);
    if (bold)
      this.element.classList.add("bold");
  }
  set(prop, value) {
    switch (prop) {
      case "value":
        this.element.value = value;
        break;
      case "label":
        this.setLabel(value);
        break;
      case "text":
        this.element.innerHTML = value;
        break;
      case "icon":
        if (this.ui.icon) {
          this.ui.icon.innerHTML = value;
        }
        break;
      case "enable":
        this.element.disabled = false;
        break;
      case "disable":
        this.element.disabled = true;
        break;
      default:
        this.element.innerHTML = prop;
    }
    return this;
  }
  setLabel(value) {
    if (this.ui.label) {
      this.ui.label.innerHTML = value;
    }
  }
  setText(value) {
    if (this.ui.label) {
      this.setLabel(value);
    } else {
      this.element.innerHTML = value;
    }
  }
  get(prop) {
    switch (prop) {
      case "value":
        return this.element.value;
      case "label":
        return this.getText();
      case "text":
        return this.getText();
      default:
        return this.element.value;
    }
  }
  getText() {
    if (this.ui.label) {
      return this.ui.label.innerHTML;
    } else {
      return this.element.innerHTML;
    }
  }
  disable() {
    this.element.disabled = true;
  }
  enable() {
    this.element.disabled = false;
  }
  click(ev) {
    if (this.options.stopPropagation === true) {
      ev.stopPropagation();
    }
    this.emit("click", ev);
  }
  select(select) {
    if (select === null) {
      this.element.classList.remove("selected");
      this.selected = null;
    } else {
      this.element.classList.add("selected");
      this.selected = true;
    }
  }
  mousedown(ev) {
    this.element.classList.add("pushed");
  }
  mouseup(ev) {
    this.element.classList.remove("pushed");
  }
};
__publicField(Button, "defaults", {
  class: "button",
  tag: "button",
  styles: ["style", "color"],
  mixins: [display_default],
  ripple: true,
  stopPropagation: false,
  events: [
    ["element.click", "click"],
    ["element.mousedown", "mousedown"],
    ["element.mouseup", "mouseup"],
    ["element.mouseleave", "mouseup"],
    ["element.touchstart", "mousedown"],
    ["element.touchend", "mouseup"]
  ]
});
var button_default = Button;

// ../node_modules/material/src/mixin/position.js
var position_default = {
  position(target, position) {
    target = target || this.options.target;
    position = position || this.options.position;
    const { offsetX = 0, offsetY = 0, align = "center", vAlign = "middle" } = position;
    if (!target)
      return this;
    this.options.container = this.options.container || this.element.parentNode;
    const caller = target.getBoundingClientRect();
    const screen2 = this.options.container.getBoundingClientRect();
    const element = this.element.getBoundingClientRect();
    let left, top;
    switch (align) {
      case "left":
        left = caller.left + caller.width;
        break;
      case "right":
        left = caller.left;
        if (left + element.width + offsetX > screen2.width) {
          left = caller.left - element.width + caller.width;
        }
        break;
      case "center":
        left = caller.left + caller.width / 2 - element.width / 2;
      default:
        left = caller.left + caller.width / 2 - element.width / 2;
    }
    if (left < 0)
      left = offsetX;
    if (left + element.width > screen2.width) {
      left = caller.left - element.width;
    }
    const scrollY = window.scrollY;
    switch (vAlign) {
      case "top":
        top = caller.top + scrollY - element.height;
        break;
      case "inline":
        top = caller.top + scrollY;
        break;
      case "bottom":
        top = caller.top + caller.height + scrollY;
        break;
      case "middle":
      case "dynamic":
        if (caller.top + caller.height / 2 < screen2.height / 2) {
          top = caller.bottom + scrollY;
        } else {
          top = caller.top + scrollY - element.height;
        }
        break;
      default:
        top = caller.top + scrollY + caller.height / 2 - element.height / 2;
    }
    if (top + element.height + offsetY > screen2.height) {
      top = screen2.height - element.height - offsetX;
    }
    this.element.style.left = `${left}px`;
    this.element.style.top = `${top}px`;
    return this;
  }
};

// ../node_modules/material/src/card.js
var Card = class extends component_default {
};
__publicField(Card, "defaults", {
  class: "card",
  mixins: [display_default, position_default],
  position: {
    align: "center",
    vAlign: "dynamic",
    offsetX: 10,
    offsetY: 10
  },
  close: true
});
var card_default = Card;

// ../node_modules/material/src/checkbox.js
import icon from "C:/Web/Backend/Lesson-7/node_modules/material/src/skin/material/icon/checkbox.svg";

// ../node_modules/material/src/element.js
var Element = class {
  static isElement() {
    return true;
  }
  constructor(options2 = {}) {
    this.options = { tag: "div", container: null, html: "", text: "", id: "", ...options2 };
    const element = document.createElement(this.options.tag);
    if (this.options.html)
      element.innerHTML = this.options.html;
    if (this.options.text)
      element.textContent = this.options.text;
    if (this.options.id)
      element.setAttribute("id", this.options.id);
    for (const key in this.options) {
      if (!["tag", "container", "html", "text", "id"].includes(key)) {
        element.setAttribute(key, this.options[key]);
      }
    }
    if (this.options.container) {
      this.options.container.appendChild(element);
    }
    return element;
  }
};
var element_default = Element;

// ../node_modules/material/src/checkbox.js
var Checkbox = class extends control_default {
  constructor(options2) {
    super(options2);
    this.setup();
  }
  setup() {
    this.ui.control.innerHTML = icon;
    const text = this.options.text || this.options.label;
    this.ui.label.innerHTML = text;
    this.ui.input.setAttribute("type", "checkbox");
    this.ui.input.setAttribute("name", this.options.name);
    this.ui.input.setAttribute("aria-label", this.options.name);
    if (this.options.value) {
      this.ui.input.setAttribute("value", this.options.value);
    }
    if (this.options.disabled) {
      this.disabled = this.options.disabled;
      this.ui.input.setAttribute("disabled", "disabled");
      this.element.classList.add("is-disabled");
    }
    if (this.options.checked) {
      this.check(true);
    }
    if (this.options.value) {
      this.set("value", this.value);
    }
  }
  set(prop, value) {
    switch (prop) {
      case "checked":
        this.check(value);
        break;
      case "value":
        this.setValue(value);
        break;
      case "label":
        this.setLabel(value);
        break;
      default:
        this.check(prop);
    }
    return this;
  }
  get() {
    return this.value;
  }
  check(value) {
    if (value === true) {
      this.element.classList.add("is-checked");
      this.ui.input.checked = true;
      this.value = true;
      this.emit("change", this.value);
    } else {
      this.element.classList.remove("is-checked");
      this.ui.input.checked = false;
      this.value = false;
      this.emit("change", this.value);
    }
    return this;
  }
  onClick(e2) {
    this.ui.input.focus();
    if (this.element.classList.add("is-checked")) {
      this.check(false);
    } else {
      this.check(true);
    }
    return this;
  }
  setValue(value) {
    this.value = value;
    this.ui.input.setAttribute("value", value);
    return this;
  }
};
__publicField(Checkbox, "defaults", {
  class: "checkbox",
  layout: [
    [element_default, "input", { type: "checkbox" }],
    [element_default, "control", { type: "checkbox" }],
    [element_default, "label", { tag: "label" }]
  ],
  events: [
    ["ui.control.click", "click"],
    ["ui.label.click", "check"],
    // for accessibility purpose
    // ['element.input.click', 'toggle'],
    ["ui.input.focus", "focus"],
    ["ui.input.blur", "blur"],
    ["ui.input.keydown", "keydown"]
  ]
});
var checkbox_default = Checkbox;

// ../node_modules/material/src/datehour.js
var DateHour = class extends component_default {
  set(date) {
    const d = new Date(date);
    const formatted = this.format(d);
    this.element.innerHTML = formatted;
  }
  format(date) {
    let hours = date.getHours();
    let minutes = date.getMinutes();
    const ampm = hours >= 12 ? "pm" : "am";
    hours = hours % 12;
    hours = hours || 12;
    minutes = minutes < 10 ? "0" + minutes : minutes;
    const strTime = hours + ":" + minutes + " " + ampm;
    return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear() + " " + strTime;
  }
};
__publicField(DateHour, "defaults", {
  class: "date",
  tag: "span"
});
var datehour_default = DateHour;

// ../node_modules/material/src/module/emitter.js
var emitter_default = {
  on(event, cb) {
    this.event = this.event || {};
    this.event[event] = this.event[event] || [];
    this.event[event].push(cb);
    return this;
  },
  off(event, cb) {
    this.event = this.event || {};
    if (event in this.event === false)
      return;
    this.event[event].splice(this.event[event].indexOf(cb), 1);
    return this;
  },
  emit(event) {
    this.event = this.event || {};
    if (event in this.event === false)
      return;
    for (let i = 0; i < this.event[event].length; i++) {
      this.event[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
    return this;
  }
};

// ../node_modules/material/src/mixin/display.js
var display_default = {
  toggle() {
    var _a;
    this.visible ? this.hide() : this.show();
    (_a = this.emit) == null ? void 0 : _a.call(this, "toggle");
    return this;
  },
  show() {
    var _a;
    if (!this.element)
      return;
    if (this.options.display !== false) {
      this.element.style.display = "";
    }
    this.element.getBoundingClientRect();
    this.element.classList.add("show");
    this.visible = true;
    if (this.underlay) {
      this.underlay.classList.add("show");
    }
    (_a = this.emit) == null ? void 0 : _a.call(this, "show");
    return this;
  },
  hide() {
    var _a;
    if (!this.element)
      return;
    this.element.classList.remove("show");
    this.visible = false;
    if (this.underlay) {
      this.underlay.classList.remove("show");
    }
    if (this.options.transition && this.element) {
      setTimeout(() => {
        if (this.options.display !== false) {
          this.element.style.display = "none";
        }
      }, this.options.transition);
    }
    (_a = this.emit) == null ? void 0 : _a.call(this, "hide");
    return this;
  },
  destroy() {
    var _a;
    if (this.options.transition && this.element) {
      this.element.classList.remove("show");
      if (this.underlay) {
        this.underlay.classList.remove("show");
      }
      setTimeout(() => {
        dom_default.destroy(this.element);
        if (this.underlay)
          dom_default.destroy(this.underlay);
      }, this.options.transition);
    } else {
      dom_default.destroy(this.element);
      if (this.underlay)
        dom_default.destroy(this.underlay);
    }
    (_a = this.emit) == null ? void 0 : _a.call(this, "destroy");
  }
};

// ../node_modules/material/src/text.js
var Text = class extends component_default {
  constructor(options2) {
    super(options2);
    this.setup();
  }
  setup() {
    if (this.options.text) {
      this.set(this.options.text);
    }
  }
  set(text) {
    if (text === "undefined")
      text = "";
    const label = this.options.label || "";
    if (this.options.textFirst) {
      this.element.innerHTML = text + label;
    } else {
      this.element.innerHTML = label + text;
    }
    if (this.options.spaceAfter) {
      this.element.innerHTML = this.element.innerHTML + " ";
    }
  }
  setText(text) {
    if (text === "undefined")
      text = "";
    this.element.innerHTML = text;
  }
  get() {
    if (this.element.innerHTML) {
      return this.element.innerHTML;
    } else {
      return "";
    }
  }
};
__publicField(Text, "defaults", {
  class: "text",
  tag: "span"
});
var text_default = Text;

// ../node_modules/material/src/dialog.js
var _Dialog = class _Dialog {
  constructor(options2) {
    this.init(options2);
    this.build();
    this.render();
    this.setup();
    return this;
  }
  init(options2) {
    this.options = { ..._Dialog.defaults, ...options2 };
    Object.assign(this, emitter_default, display_default);
  }
  build() {
    this.element = document.createElement("div");
    this.element.classList.add("dialog");
    this.element = this.element;
    if (this.options.class !== "dialog") {
      this.element.classList.add(this.options.class);
    }
    if (this.options.position) {
      this.element.classList.add("position-" + this.options.position);
    }
    this.surface = document.createElement("div");
    this.surface.classList.add("surface");
    this.element.appendChild(this.surface);
    this.layout = create(this.options.layout, this.surface);
    this.ui = this.layout.component;
    if (this.options.container) {
      this.options.container.appendChild(this.element);
    }
    if (this.options.display === "show") {
      this.show();
    }
  }
  render() {
    if (this.options.title && this.ui.title) {
      this.ui.title.set(this.options.title);
    }
    if (this.options.content && this.ui.content) {
      this.ui.content.set(this.options.content);
    }
    if (this.options.cancel && this.ui.cancel) {
      this.ui.cancel.set("text", this.options.cancel);
    }
    if (this.options.ok && this.ui.ok) {
      this.ui.ok.set("text", this.options.ok);
    }
    if (this.options.target) {
      this.setPosition();
    }
  }
  setup() {
    events_default.attach(this.options.events, this);
  }
  setPosition() {
    const coord = this.options.target.getBoundingClientRect();
    const surface_coord = this.surface.getBoundingClientRect();
    if (this.options.position === "right") {
      this.surface.style.top = coord.top + "px";
      this.surface.style.left = coord.left + coord.width;
    } else {
      this.surface.style.top = coord.top + "px";
      this.surface.style.left = coord.left - surface_coord.width + "px";
    }
  }
  ok() {
    this.emit("ok");
    if (this.options.close) {
      this.destroy();
    }
  }
  cancel() {
    this.emit("cancel");
    if (this.options.close) {
      this.destroy();
    }
  }
  close() {
    if (this.options.close) {
      this.destroy();
    }
  }
  onClick(e2) {
    e2.stopPropagation();
  }
  onClickRoot(e2) {
    e2.stopPropagation();
    if (!this.options.modal) {
      this.destroy();
    }
  }
  emphase() {
    this.element.classList.add("emphase");
    let it;
    it = setTimeout(() => {
      clearTimeout(it);
      this.element.classList.remove("emphase");
    }, 100);
  }
  set(prop, value) {
    if (this.ui[prop]) {
      this.ui[prop].set(value);
    }
  }
};
__publicField(_Dialog, "defaults", {
  class: "dialog",
  close: true,
  layout: [
    [
      element_default,
      "head",
      { class: "head" },
      [text_default, "title", { class: "title" }],
      [button_default, "close", { class: "close" }]
    ],
    [
      element_default,
      "body",
      { class: "body" },
      [text_default, "content", { class: "content" }]
    ],
    [
      element_default,
      "foot",
      { class: "foot" },
      [element_default, { class: "divider" }],
      [button_default, "ok", { class: "ok", text: "Ok", color: "primary" }]
    ]
  ],
  events: [
    ["element.click", "onClickRoot"],
    ["surface.click", "onClick"],
    ["ui.ok.click", "ok"],
    ["ui.cancel.click", "cancel"],
    ["ui.close.click", "close"]
  ]
});
var Dialog = _Dialog;
var dialog_default = Dialog;

// ../node_modules/material/src/mixin/controller.js
var instance = null;
var Controller = class {
  /**
   * Setting up block level variable to store class state
   * , set's to null by default.
   * credits: http://amanvirk.me/singleton-classes-in-es6/
   */
  constructor() {
    if (!instance) {
      instance = this;
    }
    this.components = this.components || [];
    this.component = this.component || {};
    this.init();
    return instance;
  }
  init() {
    this.subscribe("settings", (message) => {
    });
  }
  // setSettings(key, value) {
  //   var text = Cookies.get(key);
  //   var current = {};
  //   if (text) {
  //     current = JSON.parse(text);
  //   }
  //   console.log('settings value', current, value);
  //   //settings = [settings, value].reduce(Object.assign, {});
  //   var settings = merge(current, value);
  //   console.log('settings ' + key, settings);
  //   Cookies.set(key, JSON.stringify(settings));
  // }
  // getSettings(key) {
  //   var json = Cookies.get(key);
  //   if (!json) {
  //     return null;
  //   }
  //   var value = JSON.parse(json);
  //   console.log('settings' + key, value);
  //   return value;
  // }
  /**
   * [register description]
   * @param  {component} component [description]
   * @return {Object} The class instance
   */
  register(component) {
    this.components.push(component);
    this.component[component.name] = this.component[component.name] || [];
    this.component[component.name].push(component);
    return this;
  }
  /**
   * This method subscribes to a specific topic
   * @param  {string}   topic
   * @param  {Function} callback
   * @return {boolean} true
   */
  subscribe(topic, callback) {
    this._topics = this._topics || {};
    if (!this._topics.hasOwnProperty(topic)) {
      this._topics[topic] = [];
    }
    this._topics[topic].push(callback);
    return true;
  }
  /**
   * This method unsubscribes to a specific topic
   * @param  {string}   topic
   * @param  {Function} callback
   * @return {boolean} true
   */
  unsunscribe(topic, callback) {
    this._topics = this._topics || {};
    if (!this._topics.hasOwnProperty(topic)) {
      return false;
    }
    for (let i = 0, len = this._topics[topic].length; i < len; i++) {
      if (this._topics[topic][i] === callback) {
        this._topics[topic].splice(i, 1);
        return true;
      }
    }
    return false;
  }
  /**
   * [publish description]
   * @return {?} [description]
   */
  publish() {
    this._topics = this._topics || {};
    const args = Array.prototype.slice.call(arguments);
    const topic = args.shift();
    if (!this._topics.hasOwnProperty(topic)) {
      return false;
    }
    for (let i = 0, len = this._topics[topic].length; i < len; i++) {
      this._topics[topic][i].apply(void 0, args);
    }
    return true;
  }
};
__publicField(Controller, "uid", "material-mixin-controller");
var controller = new Controller();
var controller_default = controller;

// ../node_modules/material/src/mixin/init.js
function init(instance2) {
  modules(instance2);
  controller_default.register(instance2);
  return instance2;
}
function modules(instance2) {
  const modules2 = instance2.options.modules;
  for (let i = 0; i < modules2.length; i++) {
    if (typeof modules2[i] === "function") {
      modules2[i](instance2);
    } else {
      Object.assign(instance2, modules2[i]);
    }
  }
}
var init_default = init;

// ../node_modules/material/src/element/insert.js
var insert = (component, container, context = "bottom") => {
  if (!component || !container)
    return;
  const element = component.element || component;
  container = container.element || container;
  const contexts = ["top", "bottom", "after", "before"];
  const methods = ["prepend", "append", "after", "before"];
  const index = contexts.indexOf(context);
  if (index === -1) {
    return;
  }
  const method = methods[index];
  dom_default[method](container, element);
  return element;
};
var insert_default = insert;

// ../node_modules/material/src/module/classify.js
function classify(element, options2) {
  add(element, options2.prefix + "-" + options2.class);
  if (options2.name) {
    add(element, options2.class + "-" + options2.name);
  }
  if (options2.type) {
    add(element, "type-" + options2.type);
  }
  if (options2.color) {
    add(element, options2.color + "-color");
  }
  if (options2.css) {
    add(element, options2.css);
  }
  if (options2.elevation) {
    add(element, "elevation-z" + options2.elevation);
  }
  if (options2.name) {
    element.dataset.name = options2.name;
  }
  if (options2.label) {
    element.title = options2.label;
  }
  if (options2.style) {
    const styles = options2.style.split(" ");
    for (let i = 0; i < styles.length; i++) {
      add(element, "style-" + styles[i]);
    }
  }
  if (options2.data) {
    for (const property in options2.data) {
      if (options2.data.hasOwnProperty(property)) {
        element.dataset[property] = options2.data[property];
      }
    }
  }
  if (options2.theme) {
    element.classList.add(options2.theme + "-theme");
  }
}
var classify_default = classify;

// ../node_modules/material/src/mixin/events.js
var events_default2 = {
  addEvent(event, fn) {
    const element = this.element;
    function listenHandler(e2) {
      const ret = fn.apply(this, arguments);
      if (ret === false) {
        e2.stopPropagation();
        e2.preventDefault();
      }
      return ret;
    }
    function attachHandler() {
      const ret = fn.call(element, window.event);
      if (ret === false) {
        window.event.returnValue = false;
        window.event.cancelBubble = true;
      }
      return ret;
    }
    if (element.addEventListener) {
      element.addEventListener(event, listenHandler, false);
    } else {
      element.attachEvent("on" + event, attachHandler);
    }
    return this;
  },
  removeEvent(event, fn) {
    const element = this.element;
    if (element.removeEventListener) {
      element.removeEventListener(event, fn, false);
    } else if (element.detachEvent) {
      element.detachEvent("on" + event, element[fn.toString() + event]);
      element[fn.toString() + event] = null;
    } else {
      element["on" + event] = function() {
      };
    }
    return this;
  }
};

// ../node_modules/material/src/element/create.js
var create2 = (tag = "div", className) => {
  const element = document.createElement(tag);
  add(element, className);
  return element;
};
var create_default = create2;

// ../node_modules/material/src/drawer.js
var _Drawer = class _Drawer {
  constructor(options2) {
    this.options = { ..._Drawer.defaults, ...options2 };
    init_default(this);
    this.build();
    this.attach();
    this.emit("ready");
  }
  /**
   * Build Method
   * @return {Object} This class instance
   */
  build() {
    this.wrapper = create_default("div");
    classify_default(this.wrapper, this.options);
    this.element = create_default("aside");
    add(this.element, "drawer-panel");
    insert_default(this.element, this.wrapper);
    if (this.options.position) {
      add(this.element, "position-" + this.options.position);
    }
    if (this.options.fixed) {
      this.wrapper.classList.add("is-fixed");
    }
    if (this.options.size) {
      if (this.options.position === "top" || this.options.position === "bottom") {
        this.element.style = "height: " + this.options.size + "px;";
      } else {
        this.element.style = "width: " + this.options.size + "px;";
      }
    }
    if (this.options.open) {
      this.open();
    }
    if (this.options.container) {
      insert_default(this.wrapper, this.options.container);
    }
    this.emit("built", this.element);
    return this;
  }
  attach() {
    if (this.options.type === "persistent")
      return;
    if (this.options.type === "permanent")
      return;
    this.wrapper.addEventListener("click", (e2) => {
      if (this.wrapper === e2.currentTarget) {
        this.close();
      }
    });
  }
  /**
   * [toggle description]
   * @return {Object} The class instance
   */
  toggle() {
    if (this.wrapper.classList.contains("show")) {
      this.close();
    } else {
      this.open();
    }
    return this;
  }
  /**
   * [minimize description]
   * @return {Object} The class instance
   */
  close() {
    remove(this.wrapper, "show");
    return this;
  }
  /**
   * [normalize description]
   * @return {Object} The class instance
   */
  open() {
    add(this.wrapper, "show");
    return this;
  }
  /**
   * [insert description]
   * @param  {?} container [description]
   * @return {?}           [description]
   */
  insert(container, context) {
    insert_default(this.wrapper, container, context);
    return this;
  }
};
__publicField(_Drawer, "defaults", {
  prefix: "material",
  class: "drawer",
  modifier: "width",
  state: "closed",
  position: "left",
  tag: "div",
  width: "340",
  modules: [emitter_default, events_default2]
});
var Drawer = _Drawer;
var drawer_default = Drawer;

// ../node_modules/material/src/mixin/emitter.js
var EventEmitter = class {
  constructor() {
    this.events = {};
  }
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return this;
  }
  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach((listener) => listener.apply(this, args));
    }
    return this;
  }
};
var emitter_default2 = EventEmitter;

// ../node_modules/material/src/module/attributes.js
var special = ["required", "disabled", "multiple", "checked"];
var attributes = (element, options2) => {
  if (!element || !(options2 == null ? void 0 : options2.attributes))
    return;
  options2.attributes.forEach((attribute) => {
    if (options2[attribute] !== void 0) {
      const value = special.includes(attribute) ? "" : options2[attribute];
      element.setAttribute(attribute, value);
    }
  });
};
var attributes_default = attributes;

// ../node_modules/material/src/file.js
var _File = class _File {
  constructor(options2) {
    this.init(options2);
    this.build();
    this.buildInput();
    this.setup();
  }
  init(options2) {
    this.options = Object.assign({}, _File.defaults, options2 || {});
    Object.assign(this, build_default2);
  }
  buildInput() {
    this.field = document.createElement("div");
    this.field.classList.add("field");
    this.element.appendChild(this.field);
    this.input = document.createElement("input");
    this.input.setAttribute("type", "file");
    this.element.appendChild(this.input);
    attributes_default(this.input, this.options);
    this.field.appendChild(this.input);
    if (this.options.focus) {
      this.input.focus();
    }
  }
  setup() {
    events_default.attach(this.options.events, this);
  }
  change(e2) {
    this.emit("change", e2);
  }
  image(e2) {
  }
  reset() {
    this.input.value = "";
  }
  set(image) {
  }
  setLabel(value) {
    if (this.label) {
      this.label.innerHTML = value;
    }
  }
  setText(value) {
    this.setLabel(value);
  }
};
__publicField(_File, "defaults", {
  class: "file",
  attributes: ["name", "accept", "required", "disabled", "multiple"],
  events: [
    ["input.change", "change"]
  ]
});
var File = _File;
var file_default = File;

// ../node_modules/material/src/form.js
var _Form = class _Form {
  constructor(options2) {
    this.options = Object.assign({}, _Form.defaults, options2 || {});
    this.init();
    this.build();
    events_default.attach(this.options.events, this);
    return this;
  }
  /**
   * Initialize View
   * @return {void}
   */
  init() {
    Object.assign(
      this,
      emitter_default,
      attach,
      insert_default
    );
    this.document = window.document;
    this.controller = controller_default;
    if (this.options.render) {
      this.render = this.options.render;
    }
    return this;
  }
  /**
   * [_initForm description]
   * @return {Object} This class instance
   */
  build() {
    const tag = this.options.tag || "div";
    this.element = document.createElement(tag);
    add(this.element, this.options.prefix + "-" + this.options.class);
    this.options.root = this.element;
    this.layout = create(this.options.layout, this.element);
    this._initControls(this.layout.controls);
    return this;
  }
  insert(container, context) {
    insert_default(this.element, container, context);
    return this;
  }
  /**
   * [_initControls description]
   * @param  {?} controls [description]
   * @return {?}          [description]
   */
  _initControls(controls) {
    if (!controls)
      return;
    this.key = this.key || {};
    for (let i = 0; i < controls.length; i++) {
      const control2 = controls[i];
      this.key[control2.name] = control2;
      control2.on("change", function() {
      });
    }
  }
  /**
   * [_onSubmit description]
   * @return {void}
   */
  _onSubmit(e2) {
    e2.preventDefault();
  }
  /**
   * [initControl description]
   * @param  {?} key     [description]
   * @param  {?} section [description]
   * @return {?}         [description]
   */
  initControl(key, section) {
    const name = key.name || "undefined";
    const control2 = this.render(key);
    if (control2) {
      this.key[name] = control2;
      control2.insert(section);
      control2.addEvent("keyup", function() {
      });
      control2.setAttribute("data-key", name);
    }
    return this;
  }
  /**
   * Getter
   *
   * @param {string} prop
   * @param {string} value
   * @return {Object|void}
   */
  set(prop, value) {
    switch (prop) {
      case "info":
        return this.setInfo(value);
      case "schema":
        return this.setSchema(value);
      default:
        return this.setInfo(prop);
    }
  }
  /**
   * [setInfo description]
   * @param {?} info [description]
   */
  setInfo(info) {
    this.info = this.original = info;
    this.parseInfo(info);
  }
  /**
   * [parseInfo description]
   * @param  {?} obj  [description]
   * @param  {?} name [description]
   * @param  {?} i    [description]
   * @return {?}      [description]
   */
  parseInfo(obj, name, i) {
    let level = i || 0;
    level = level + 1;
    let key;
    if (obj instanceof Object) {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          let n = null;
          if (name) {
            n = name + "." + key;
          } else {
            n = key;
          }
          this.parseInfo(obj[key], n, level);
        }
      }
    } else {
      if (this.key[name] && this.key[name].set) {
        this.key[name].set(obj);
      }
    }
  }
  /**
   * Getter
   *
   * @param {string} prop
   * @param {string} value
   * @return {Object|void}
   */
  get(prop, value) {
    switch (prop) {
      case "key":
        return this.getValue(value);
      case "info":
        return this.getInfo();
      case "original":
        return this.original;
      case "options":
        return this.options;
      default:
        return this.getInfo();
    }
  }
  // /**
  //  * Get Value for the given key
  //  * @param  {string} name defined in dot notation
  //  * @param  {Object} info
  //  * @return {Mixin} The Value of the given key
  //  */
  // getValue(name, info) {
  //   var keys = name.split(/\./);
  //   var value = null;
  //   if (!name || !info) {
  //     return;
  //   }
  //   //_log.debug('getValueFromKey', name, info);
  //   if (keys.length === 1) {
  //     value = info[keys[0]];
  //   }
  //   if (keys.length === 2 && info[keys[0]]) {
  //     if (info[keys[0]]) {
  //       value = info[keys[0]][keys[1]];
  //     }
  //   }
  //   if (keys.length === 3) {
  //     if (info[keys[0]]) {
  //       if (info[keys[0]][keys[1]]) {
  //         value = info[keys[0]][keys[1]][keys[2]];
  //       }
  //     }
  //   }
  //   return value;
  // }
  getInfo() {
    return this.info;
  }
};
__publicField(_Form, "defaults", {
  prefix: "material",
  class: "form",
  tag: "div",
  controls: ["textfield", "checkbox", "slider", "switch"]
});
var Form = _Form;
var form_default = Form;

// ../node_modules/material/src/image.js
var _Image = class _Image {
  constructor(options2) {
    this.init(options2);
    this.build();
  }
  init(options2) {
    this.options = { ..._Image.defaults, ...options2 };
    Object.assign(this, build_default2);
  }
  set(src) {
    if (!src) {
      this.element.style.backgroundImage = "";
    } else {
      let url = null;
      if (src.format) {
        let format = this.sanitize(src.format);
        if (format.length > 0) {
          const index = format.indexOf(this.options.format);
          if (index === -1) {
            format = src.format[0] + "/";
          } else {
            format = this.options.format + "/";
          }
        }
        url = src.url + format;
      } else {
        url = src.url;
      }
      this.element.style.backgroundImage = "url(" + url + src.filename + ")";
    }
  }
  sanitize(formats) {
    const a = [];
    for (let i = 0; i < formats.length; i++) {
      const format = formats[i].replace(/\/$/, "");
      a.push(format);
    }
    return a;
  }
};
__publicField(_Image, "defaults", {
  class: "image",
  tag: "div",
  format: "thumb"
});
var Image = _Image;
var image_default = Image;

// ../node_modules/material/src/list.js
var _List = class _List {
  constructor(options2) {
    this.init(options2);
    this.build();
  }
  init(otions) {
    this.options = { ..._List.defaults, ...options };
  }
  build() {
    this.element = document.createElement(this.options.tag);
    add(this.element, this.options.class);
    if (this.options.class !== "text") {
      this.element.classList.add("text");
    }
    if (this.options.list) {
      this.set(this.options.list);
    }
    if (this.options.container) {
      this.options.container.appendChild(this.element);
    }
    return this;
  }
  set(list2) {
    let text = "";
    for (let i = 0; i < list2.length; i++) {
      if (i < list2.length - 1) {
        text = text + list2[i] + this.options.seprator;
      } else {
        text = text + list2[i];
      }
    }
    if (text === void 0)
      return;
    const label = this.options.label || "";
    this.element.innerHTML = label + text;
    if (this.options.spaceAfter) {
      this.element.innerHTML = this.element.innerHTML + " ";
    }
  }
  setText(text) {
    this.element.innerHTML = text;
  }
};
__publicField(_List, "defaults", {
  className: "text",
  tag: "span",
  seprator: " | "
});
var List = _List;
var list_default = List;

// ../node_modules/material/src/loading.js
var _Loading = class _Loading {
  constructor(options2) {
    this.init(options2);
    this.build();
    this.buildLoading();
  }
  init(options2) {
    this.options = { ..._Loading.defaults, ...options2 };
    Object.assign(this, build_default2);
  }
  buildLoading(options2) {
    if (this.options.type === "circular") {
      this.element.innerHTML = this.options.circular;
    }
    if (this.options.type === "indeterminate") {
      this.bar = document.createElement(this.options.tag);
      this.bar.classList.add("bar");
      this.element.classList.add("type-indeterminate");
      this.element.appendChild(this.bar);
    }
  }
  set(progress) {
    this.bar.setAttribute("style", "width: " + progress);
  }
  show(delay) {
    delay = delay || this.options.delay;
    clearTimeout(this.showTimeout);
    this.showTimeout = setTimeout(() => {
      this.element.classList.add("show");
    }, this.options.delay);
    this.visible = true;
    return this;
  }
  showNow() {
    this.element.classList.add("show");
    this.visible;
    return this;
  }
  hide() {
    clearTimeout(this.showTimeout);
    this.element.classList.remove("show");
    this.visible = false;
    return this;
  }
};
__publicField(_Loading, "defaults", {
  class: "loading",
  tag: "div",
  delay: 1e3,
  type: "indeterminate",
  circular: `<svg class="progress" width="65px" height="65px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
        <circle class="path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
      </svg>`
});
var Loading = _Loading;
var loading_default = Loading;

// ../node_modules/material/src/menu.js
var _Menu = class _Menu extends control_default {
  constructor(options2) {
    super(options2);
    this.setup();
    this.render(this.options.items);
  }
  setup() {
    this.menus = [];
    this.closeTimeout = null;
    document.addEventListener("click", this.handleDocumentClick);
  }
  render(items) {
    if (items && Array.isArray(items)) {
      for (let i = 0; i < items.length; i++) {
        this.add(items[i]);
      }
    }
    return this;
  }
  add(obj) {
    if (typeof obj !== "object")
      return this;
    let item;
    if (obj.type === "divider") {
      item = new element_default({ tag: "li", class: "divider" });
    } else {
      obj.tag = "li";
      obj.class = obj.class ? obj.class + " item" : "item";
      item = new element_default(obj);
      item.addEventListener("mouseenter", () => {
        if (this.menu) {
          this.menu.destroy();
        }
      });
      if (obj.items && Array.isArray(obj.items)) {
        item.classList.add("sub");
        item.addEventListener("mouseenter", () => {
          this.menu = new _Menu({
            class: "floating",
            target: item,
            container: this.options.container,
            underlay: false,
            parentName: obj.name,
            items: obj.items
          }).position(item, {
            align: "left",
            vAlign: "inline",
            offsetX: 8,
            offsetY: 8
          }).show();
          this.menu.on("select", (value, name) => {
            this.emit("select", `${obj.name}:${value}`, name);
          }).on("destroy", () => {
            this.menu = null;
          });
          this.menus.push(this.menu);
        });
      }
    }
    this.ui.list.appendChild(item);
    return this;
  }
  onClick(ev) {
    if (ev.target.classList.contains("sub"))
      return;
    const value = ev.target.getAttribute("name");
    const name = ev.target.innerHTML;
    if (value) {
      this.emit("select", value, name);
    }
  }
  destroyMenu(menu) {
    const index = this.menus.indexOf(menu);
    if (index > -1) {
      this.menus.splice(index, 1);
    }
    menu.destroy();
  }
  close() {
    this.menus.forEach((menu) => {
      menu.destroy();
    });
    this.menus = [];
    this.destroy();
  }
};
__publicField(_Menu, "defaults", {
  class: "menu",
  mixins: [display_default, position_default],
  underlay: true,
  modal: false,
  position: {
    align: "right",
    vAlign: "bottom",
    offsetX: 10,
    offsetY: 10
  },
  layout: [
    [element_default, "list", { tag: "ul", class: "items" }]
  ],
  events: [
    ["element.click", "onClick"],
    ["select", "destroy"],
    ["underlay.click", "close"]
  ]
});
var Menu = _Menu;
var menu_default = Menu;

// ../node_modules/material/src/item.js
var _Item = class _Item {
  constructor(options2) {
    this.init(options2);
    this.build();
    this.setup();
  }
  setup() {
    if (this.options.text)
      this.set(this.options.text);
    if (this.options.name)
      this.element.setAttribute("name", this.options.name);
  }
  init(options2) {
    this.options = Object.assign({}, _Item.defaults, options2 || {});
    Object.assign(this, build_default2);
    this.options.tag = this.options.tag || this.options.types[this.options.type];
  }
  set(value) {
    if (value) {
      if (this.element.innerText) {
        this.element.innerText = value;
      } else {
        this.element.textContent = value;
      }
    }
    return this;
  }
};
__publicField(_Item, "defaults", {
  prefix: "material",
  class: "item",
  type: "default",
  tag: "span",
  types: {
    default: "span",
    display4: "h1",
    display3: "h1",
    display2: "h1",
    display1: "h1",
    headline: "h1",
    title: "h2",
    subheading2: "h3",
    subheading1: "h4",
    body: "p",
    body2: "aside",
    caption: "span"
  }
});
var Item = _Item;
var item_default = Item;

// ../node_modules/material/src/navigation.js
var _Navigation = class _Navigation extends emitter_default2 {
  constructor(options2) {
    super();
    this.init(options2);
    this.build();
    this.setup();
  }
  init(options2) {
    this.options = { ..._Navigation.defaults, ...options2 };
    Object.assign(this, build_default2, display_default);
    this.items = [];
  }
  setup() {
    events_default.attach(this.options.events, this);
    if (this.options.type)
      add(this.element, "type-" + this.options.type);
    if (this.options.type === "rail")
      this.show();
    if (this.options.items)
      this.render(this.options.items);
  }
  render(items) {
    console.log("render", items);
    if (items && Array.isArray(items)) {
      for (let i = 0; i < items.length; i++) {
        this.add(items[i]);
      }
    }
  }
  add(obj) {
    if (typeof obj !== "object")
      return this;
    let item;
    if (obj.type === "header") {
      item = new element_default({ tag: "span", class: "header" });
    } else if (obj.type === "divider") {
      item = new element_default({ tag: "span", class: "divider" });
    } else {
      obj.container = this.ui.body;
      obj.class = "item";
      obj.stopPropagation = true;
      obj.class = "item";
      item = new item_default(obj);
      console.log("item", item, this.items);
      this.items.push(item);
    }
    return this;
  }
};
__publicField(_Navigation, "defaults", {
  class: "navigation",
  tag: "nav",
  layout: [
    [element_default, "body", { class: "body" }]
  ],
  events: [
    ["element.click", "toggle"]
  ]
});
var Navigation = _Navigation;
var navigation_default = Navigation;

// ../node_modules/material/src/progress.js
var _Spinner = class _Spinner {
  constructor(options2) {
    this.init(options2);
    this.build();
    return this;
  }
  init(options2) {
    this.options = { ..._Spinner.defaults, ...options2 };
    Object.assign(this, insert_default);
  }
  build(options2) {
    this.element = create_default(this.options.tag);
    classify_default(this.element, this.options);
    if (this.options.type === "circular") {
      this.element.innerHTML = this.options.circular;
    }
    if (this.options.type === "indeterminate") {
      this.bar = create_default("div", "bar");
      insert_default(this.bar, this.element);
    } else {
      this.bar = create_default("div", "bar");
      insert_default(this.bar, this.element);
      this.set(this.options.progress);
    }
    if (this.options.container) {
      insert_default(this.element, this.options.container);
    }
    return this;
  }
  set(progress) {
    this.bar.setAttribute("style", "width: " + progress);
  }
};
__publicField(_Spinner, "defaults", {
  prefix: "material",
  class: "progress",
  tag: "div",
  progress: "0%",
  circular: `<svg class="progress" width="65px" height="65px" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg">
      <circle class="path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle>
    </svg>`
});
var Spinner = _Spinner;
var progress_default = Spinner;

// ../node_modules/material/src/select.js
var _Select = class _Select extends emitter_default2 {
  constructor(options2) {
    super();
    this.init(options2);
    this.build();
    this.buildLabel();
    this.buildInput();
    events_default.attach(this.options.events, this);
  }
  init(options2) {
    this.options = { ..._Select.defaults, ...options2 };
    Object.assign(this, build_default2, dataset_default);
  }
  buildLabel() {
    if (this.options.label) {
      this.label = document.createElement("span");
      this.label.classList.add("label");
      this.label.innerHTML = this.options.label;
      this.element.appendChild(this.label);
    }
  }
  buildInput() {
    this.input = document.createElement("select");
    this.input.classList.add("input");
    this.element.appendChild(this.input);
    this.input.addEventListener("change", () => {
      this.emit("change", this.input[this.input.selectedIndex].value);
    });
    if (this.options.data) {
      dataset_default(this.data, this.options.data);
    }
    attributes_default(this.input, this.options);
    if (this.options.options) {
      this.setOptions(this.options.options);
    }
  }
  setOptions(options2) {
    const first = this.options.first;
    if (first && first[0] && first[1]) {
      this.input.options[0] = new Option(first[1], first[0]);
    }
    for (let i = 0; i < options2.length; i++) {
      this.addOption(options2[i][1], options2[i][0]);
    }
  }
  addOption(name, value) {
    this.input.options[this.input.options.length] = new Option(name, value);
  }
  set(value) {
    this.input.value = value;
    return this;
  }
  setLabel(value) {
    if (this.label) {
      this.label.innerHTML = value;
    }
  }
  setText(value) {
    this.setLabel(value);
  }
  get() {
    let value = null;
    if (this.input[this.input.selectedIndex]) {
      value = this.input[this.input.selectedIndex].value;
    }
    return value;
  }
};
__publicField(_Select, "defaults", {
  type: "list",
  class: "select",
  first: null,
  attributes: ["type", "name", "autocomplete", "required"]
});
var Select = _Select;
var select_default = Select;

// ../node_modules/material/src/selecter.js
var _Selecter = class _Selecter extends emitter_default2 {
  constructor(options2) {
    super();
    this.init(options2);
    this.build();
    this.setup();
  }
  init(options2) {
    this.options = { ..._Selecter.defaults, ...options2 };
    Object.assign(this, dataset_default);
  }
  setup() {
    events_default.attach(this.options.events, this);
    if (this.options.data) {
      dataset_default(this.element, this.options.data);
    }
    attributes_default(this.ui.input, this.options);
    if (this.value) {
      this.element.input.setAttribute("checked", "checked");
    }
    if (this.options.tooltip) {
      this.element.setAttribute("data-tooltip", this.options.tooltip);
    }
    if (this.options.label) {
      this.setLabel(this.options.label);
    }
    this.ui.input.setAttribute("aria-label", this.options.name);
    if (this.options.case) {
      this.element.classList.add(this.options.case + "-case");
    }
  }
  /**
   * build method
   * @return {Object} The class instance
   */
  build() {
    const tag = this.options.tag || "span";
    this.element = document.createElement(tag);
    this.element.classList.add("selecter");
    if (this.options.class !== "selecter") {
      add(this.element, this.options.class);
    }
    this.layout = create(this.options.layout, this.element);
    this.ui = this.layout.component;
    this.styleAttributes();
    this.buildIcon(this.options.icon);
    this.setList(this.options.list);
    if (this.options.container) {
      this.options.container.appendChild(this.element);
    }
  }
  buildIcon(icon3) {
    if (!icon3)
      return;
    this.ui.icon = document.createElement("i");
    this.ui.icon.classList.add("icon");
    this.ui.icon.innerHTML = this.options.icon;
    this.element.insertBefore(this.ui.icon, this.ui.input);
  }
  buildInput() {
    this.input = document.createElement("select");
    this.input.classList.add("input");
    this.element.appendChild(this.input);
    this.input.addEventListener("change", () => {
      this.emit("change", this.input[this.input.selectedIndex].value);
    });
    if (this.options.data) {
      dataset_default(this.data, this.options.data);
    }
    attributes_default(this.input, this.options);
  }
  setList(list2) {
    if (!list2)
      return;
    this.values = {};
    for (let i = 0; i < list2.length; i++) {
      const item = document.createElement("div");
      item.classList.add("item");
      item.innerHTML = list2[i][1];
      item.dataset.value = list2[i][0];
      this.values[list2[i][0]] = list2[i][1];
      this.ui.body.appendChild(item);
    }
  }
  styleAttributes() {
    if (this.options.style) {
      this.element.classList.add("style-" + this.options.style);
    }
    if (this.options.size) {
      this.element.classList.add(this.options.size + "-size");
    }
    if (this.options.color) {
      this.element.classList.add("color-" + this.options.color);
    }
    if (this.options.bold) {
      this.element.classList.add("bold");
    }
  }
  showList() {
    this.ui.list.classList.add("show");
  }
  hideList() {
    this.ui.list.classList.remove("show");
  }
  select(e2) {
    e2.preventDefault();
    if (e2 && e2.target && e2.target.dataset.value) {
      if (this.selected) {
        this.selected.classList.remove("selected");
      }
      this.selected = e2.target;
      this.selected.classList.add("selected");
      this.value = e2.target.dataset.value;
      this.ui.value.innerHTML = this.values[this.value];
      this.emit("change", this.value);
    }
    if (this.options.type !== "listonly") {
      this.hideList();
    }
  }
  addOption(name, value) {
    this.input.options[this.input.options.length] = new Option(name, value);
  }
  set(value) {
    this.ui.input.value = value;
    if (this.values) {
      this.ui.value.innerHTML = this.values[value];
    }
    this.selected = this.element.querySelector("[data-value=" + value + "]");
    if (this.selected) {
      this.selected.classList.add("selected");
    }
    return this;
  }
  setLabel(value) {
    if (this.ui.label) {
      this.ui.label.innerHTML = value;
      this.ui.title.innerHTML = value;
    }
  }
  setText(value) {
    this.setLabel(value);
  }
  get() {
    return this.value;
  }
};
__publicField(_Selecter, "defaults", {
  class: "selecter",
  first: null,
  attributes: ["type", "name", "autocomplete", "required"],
  layout: [
    [element_default, "label", { tag: "label", class: "label" }],
    [element_default, "value", { tag: "value", class: "value" }],
    [element_default, "input", { tag: "input", type: "text", class: "input" }],
    [
      element_default,
      "list",
      { class: "list" },
      [
        element_default,
        "head",
        { class: "head" },
        [element_default, "title", { class: "title" }],
        [button_default, "close", { class: "close" }]
      ],
      [element_default, "body", { class: "body" }]
    ]
  ],
  events: [
    ["ui.value.click", "showList"],
    ["ui.list.click", "select"],
    ["ui.close.click", "hideList"]
  ]
});
var Selecter = _Selecter;
var selecter_default = Selecter;

// ../node_modules/material/src/snackbar.js
var Snackbar = class extends control_default {
  constructor(options2) {
    super(options2);
    this.init(options2);
    this.render();
    this.show();
    if (this.options.duration) {
      setTimeout(() => {
        this.destroy();
      }, this.options.duration);
    }
  }
  init(options2) {
    this.buildSnackbarContainer(this.options.container);
  }
  buildSnackbarContainer(container = document.body) {
    const snackbarContainer = container.querySelector(".snackbars");
    if (!snackbarContainer) {
      this.options.container = document.createElement("div");
      this.options.container.classList.add("snackbars");
      container.appendChild(this.options.container);
    } else {
      if (this.options.stack === false)
        snackbarContainer.innerHTML = "";
      this.options.container = snackbarContainer;
    }
    this.options.container.appendChild(this.element);
  }
  render() {
    if (!this.ui) {
      console.error("UI elements not initialized properly.");
      return;
    }
    const { message, callback, close, action } = this.ui;
    if (message) {
      message.set(this.options.message);
    } else {
      console.error("Message UI element not initialized.");
    }
    if (this.options.action && callback && callback.element) {
      callback.set(this.options.action);
      callback.element.classList.add("show");
      if (action) {
        action.classList.add("show");
      }
    }
    if (this.options.close && close && close.element) {
      close.element.classList.add("show");
      if (action) {
        action.classList.add("show");
      }
    }
  }
  action() {
    this.emit("action");
    this.destroy();
  }
  close() {
    this.destroy();
  }
};
__publicField(Snackbar, "defaults", {
  class: "snackbar",
  mixins: [display_default],
  transition: 225,
  duration: 4e3,
  stack: false,
  close: false,
  layout: [
    [text_default, "message", { tag: "span", class: "message" }],
    [
      element_default,
      "action",
      { tag: "span", class: "action" },
      [button_default, "callback", { class: "callback", type: "link" }],
      [button_default, "close", { class: "close", type: "action" }]
    ]
  ],
  events: [
    ["ui.callback.click", "action"],
    ["ui.close.click", "destroy"]
  ]
});
var snackbar_default = Snackbar;

// ../node_modules/material/src/element/attribute.js
var init2 = (element, attribute) => {
  for (const key in attribute) {
    if (Object.prototype.hasOwnProperty.call(attribute, key)) {
      element.setAttribute(key, attribute[key]);
    }
  }
  return element;
};
var set = (element, name, value) => {
  return element.setAttribute(name, `${value}`);
};
var get = (element, name) => {
  return element.getAttribute(name) || null;
};
var remove3 = (element, name) => {
  return element.removeAttribute(name);
};
var attribute_default = { init: init2, set, get, remove: remove3 };

// ../node_modules/material/src/element/build.js
var isObject = (object) => {
  return object && typeof object === "object" && Object.getPrototypeOf(object) === Object.getPrototypeOf({});
};
var process = (string) => {
  const tags = string.match(/^[\w-]+/);
  const ids = string.match(/#([\w-]+)/);
  const classes = string.match(/\.[\w-]+/g);
  const names = string.match(/\$([\w-]+)/);
  const properties = {
    tag: tags ? tags[0] : "div"
  };
  if (ids)
    properties.id = ids[1];
  if (names)
    properties.name = names[1];
  if (classes) {
    properties.class = classes.join(" ").replace(/\./g, "");
  }
  return properties;
};
var build2 = (schema, container, object = {}, level) => {
  let element;
  for (let i = 0; i < schema.length; i++) {
    if (typeof schema[i] === "string") {
      const property = process(schema[i]);
      element = create_default(property.tag, property.class);
      insert_default(element, container);
      if (property.name)
        object[property.name] = element;
    } else if (isObject(schema[i])) {
      attribute_default.init(element, schema[i]);
    } else if (Array.isArray(schema[i])) {
      build2(schema[i], element, object, level);
    }
  }
  return object;
};
var build_default3 = build2;

// ../node_modules/material/src/mixin/control.js
var KEYCODE = {
  ENTER: 13,
  SPACE: 32
};
var control = {
  toggle() {
    if (this.disabled)
      return;
    this.focus();
    if (this.checked) {
      this.check(false);
    } else {
      this.check(true);
    }
    return this;
  },
  check(checked) {
    if (checked === true) {
      add(this.element, "is-checked");
      this.element.input.checked = true;
      this.checked = true;
      this.emit("change", this.checked);
    } else {
      remove(this.element, "is-checked");
      this.element.input.checked = false;
      this.checked = false;
      this.emit("change", this.checked);
    }
    return this;
  },
  label(label, container) {
    if (!label)
      return;
    this.element = this.element || {};
    if (!this.element.label) {
      this.element.label = create_default("label", this.options.class + "-label");
    }
    this.element.label.textContent = label;
    container = container || this.element;
    insert_default(this.element.label, container);
  },
  icon(icon3, container, position) {
    if (!icon3)
      return;
    container = container || this.element;
    position = position || "top";
    if (this.options.type === "text-icon") {
      position = "bottom";
    }
    this.element = this.element || {};
    this.element.icon = create_default("i", this.options.class + "-icon");
    insert_default(this.element.icon, container, position);
    this.element.icon.innerHTML = icon3;
  },
  error(error) {
    error = error || this.options.error;
    if (this.options.error === null)
      return;
    const text = this.options.error || this.options.text;
    if (!this.element.error) {
      this.element.error = create_default("error", this.options.class + "-error");
    }
    if (text) {
      this.element.error.textContent = text;
    }
    insert_default(this.element.error, this.element, "bottom");
  },
  disable() {
    this.disabled = true;
    this.element.input.setAttribute("disabled", "disabled");
    add(this.element, "is-disabled");
    return this;
  },
  enable() {
    this.disabled = false;
    this.element.input.removeAttribute("disabled");
    remove(this.element, "is-disabled");
    return this;
  },
  keydown(e2) {
    if (e2.altKey)
      return;
    switch (e2.keyCode) {
      case KEYCODE.ENTER:
      case KEYCODE.SPACE:
        e2.preventDefault();
        this.toggle(e2);
        break;
      default:
        break;
    }
  },
  get(prop) {
    switch (prop) {
      case "name":
        this.getName();
        break;
      default:
        this.setValue(prop);
    }
    return this;
  },
  getName() {
    return this.element.dataset.name;
  },
  focus() {
    if (this.disabled === true)
      return this;
    add(this.element, "is-focused");
    if (this.element.input !== document.activeElement) {
      this.element.input.focus();
    }
    return this;
  },
  blur() {
    remove(this.element, "is-focused");
    return this;
  }
};
var control_default2 = control;

// ../node_modules/material/src/module/utils.js
var isArray = (object) => {
  return Object.prototype.toString.call(object) === "[object Array]";
};
var isLiteralObject = (object) => {
  return object && typeof object === "object" && Object.getPrototypeOf(object) === Object.getPrototypeOf({});
};
var isIterable = (object) => {
  return isLiteralObject(object) || isArray(object) || typeof object === "object" && object !== null && object.length !== void 0;
};
var each = (object, callback) => {
  if (isArray(object) || typeof object === "object" && object.length !== void 0) {
    for (let i = 0, l = object.length; i < l; i++) {
      callback.apply(object[i], [object[i], i]);
    }
    return;
  }
  if (isLiteralObject(object)) {
    for (const key in object) {
      callback.apply(object[key], [object[key], key]);
    }
  }
};

// ../node_modules/material/src/element/style.js
function get2(element, style) {
  if (isArray(style)) {
    const css = {};
    for (const i in list) {
      css[list[i]] = this.get(element, list[i]);
    }
    return css;
  } else {
    let computedStyle;
    if (typeof window.getComputedStyle === "function") {
      computedStyle = window.getComputedStyle(element);
    } else if (typeof document.currentStyle !== void 0) {
      computedStyle = element.currentStyle;
    } else {
      computedStyle = element.style;
    }
    if (style) {
      return computedStyle[style];
    } else {
      return computedStyle;
    }
  }
}
function set2(element, style) {
  if (isIterable(element) && _isLiteralObject(style)) {
    each(element, function(e2) {
      set2(e2, style);
    });
    return element;
  }
  if (isLiteralObject(style)) {
    for (const i in style) {
      element.style[i] = style[i];
    }
    return style;
  }
  return false;
}
var style_default = { get: get2, set: set2 };

// ../node_modules/material/src/element/offset.js
function offset(element, prop) {
  const rect = element.getBoundingClientRect();
  const offset2 = {
    top: Math.round(rect.top),
    right: Math.round(rect.right),
    bottom: Math.round(rect.bottom),
    left: Math.round(rect.left),
    width: rect.width ? Math.round(rect.width) : Math.round(element.offsetWidth),
    height: rect.height ? Math.round(rect.height) : Math.round(element.offsetHeight)
  };
  if (offset2.width <= 0) {
    offset2.width = parseFloat(style_default.get(element, "width"));
  }
  if (offset2.height <= 0) {
    offset2.height = parseFloat(style_default.get(element, "height"));
  }
  if (prop) {
    return offset2[prop];
  } else {
    return offset2;
  }
}
var offset_default = offset;

// ../node_modules/material/src/slider.js
import icon2 from "C:/Web/Backend/Lesson-7/node_modules/material/src/skin/material/icon/pin.svg";
var _Slider = class _Slider {
  constructor(options2) {
    this.init(this.options);
    this.build(this.options);
    this.setup();
  }
  init(options2) {
    this.options = Object.assign({}, _Slider.defaults, options2 || {});
    init_default(this);
  }
  setup() {
    events_default2.attach(this.options.events, this);
  }
  build() {
    this.element = build_default3(this.options.build);
    this.element = this.element.root;
    classify_default(this.element, this.options);
    if (this.options.container) {
      insert_default(this.element, this.options.container);
    }
    const value = this.element.marker.innerHTML;
    this.element.marker.innerHTML = icon2 + value;
    if (this.options.type) {
      add(this.element, "type-" + this.options.type);
    }
    if (this.options.disabled) {
      this.disable(true);
    }
    const text = this.options.label || this.options.text;
    this.element.label.textContent = text;
    this.options.label = this.options.label || this.options.text;
    this.initTrack();
    const delay = 50;
    setTimeout(() => {
      this.initCanvas();
    }, delay);
  }
  initCanvas() {
    window.addEventListener("resize", () => {
      console.log("resize");
      this.drawCanvas();
    }, false);
    this.drawCanvas();
  }
  drawCanvas() {
    const width = offset_default(this.element.track, "width");
    const height = offset_default(this.element.track, "height");
    this.element.canvas.width = width;
    this.element.canvas.height = height;
    const context = this.element.canvas.getContext("2d");
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(0, height / 2 + 1);
    context.lineTo(width, height / 2 + 1);
    context.strokeStyle = "rgba(34, 31, 31, .26)";
    context.stroke();
  }
  /**
   * [buildControl description]
   * @return {?} [description]
   */
  initTrack() {
    this.element.track.addEventListener("mousedown", (ev) => {
      if (this.disabled === true)
        return;
      this.initTrackSize();
      const position = ev.layerX;
      this.update(position);
    });
    this.element.knob.addEventListener("click", (ev) => {
      ev.stopPropagation();
    });
    this.initDragging();
    const delay = 100;
    setTimeout(() => {
      this.setValue(this.options.value);
    }, delay);
  }
  initTrackSize() {
    this._tracksize = offset_default(this.element.track, "width");
    this._knobsize = offset_default(this.element.knob, "width");
    this._markersize = 32;
    this._trackleft = offset_default(this.element.track, "left");
    return this;
  }
  /**
   * [initDragging description]
   * @return {?} [description]
   */
  initDragging() {
    this.element.knob.onmousedown = (e2) => {
      if (this.disabled === true)
        return;
      e2.stopPropagation();
      e2 = e2 || window.event;
      add(this.element.control, "dragging");
      let start = 0;
      let position = 0;
      if (e2.pageX)
        start = e2.pageX;
      else if (e2.clientX)
        start = e2.clientX;
      start = this._trackleft;
      document.body.onmousemove = (e3) => {
        if (this.disabled === true)
          return;
        console.log("mousedown", this.disabled);
        e3 = e3 || window.event;
        let end = 0;
        if (e3.pageX)
          end = e3.pageX;
        else if (e3.clientX)
          end = e3.clientX;
        position = end - start;
        this.update(position);
      };
      document.body.onmouseup = (e3) => {
        document.body.onmousemove = document.body.onmouseup = null;
        e3 = e3 || window.event;
        let end = 0;
        if (e3.pageX)
          end = e3.pageX;
        else if (e3.clientX)
          end = e3.clientX;
        position = end - start;
        this.update(position);
        remove(this.element.control, "dragging");
      };
    };
  }
  update(position) {
    const size = this._tracksize;
    const range = this.options.range[1] - this.options.range[0];
    if (position > size) {
      position = size;
    }
    if (position < 0) {
      position = 0;
    }
    const ratio = size / position;
    const value = Math.round(range / ratio) + this.options.range[0];
    if (position === 0) {
      remove(this.element.knob, "notnull");
    }
    this.element.knob.style.left = position - this._knobsize / 2 + "px";
    this.element.trackvalue.style.width = position + "px";
    this.element.marker.style.left = position - this._markersize / 2 + "px";
    this.element.value.textContent = value;
    this.element.input.value = value;
    if (value > this.options.range[0]) {
      add(this.element.knob, "notnull");
    } else {
      remove(this.element.knob, "notnull");
    }
  }
  updateValue(value) {
    this.initTrackSize();
    let size = offset_default(this.element.track, "width");
    size = parseInt(size);
    const range = this.options.range[1] - this.options.range[0];
    const ratio = value * 100 / range;
    const position = Math.round(size * ratio / 100);
    this.update(position);
    return this;
  }
  /**
   * [insert description]
   * @param  {?} container [description]
   * @param  {?} context   [description]
   * @return {?}           [description]
   */
  insert(container, context) {
    insert_default(this.element, container, context);
  }
  /**
   * Setter
   * @param {string} prop
   * @param {string} value
   */
  set(prop, value) {
    switch (prop) {
      case "value":
        this.setValue(value);
        break;
      case "label":
        this.setLabel(value);
        break;
      default:
        this.setValue(prop);
    }
    return this;
  }
  /**
   * Getter
   * @param {string} prop
   * @param {string} value
   */
  get(prop) {
    let value;
    switch (prop) {
      case "value":
        value = this.getValue();
        break;
      case "name":
        value = this.name;
        break;
      default:
        return this.getValue();
    }
    return value;
  }
  /**
   * [getValue description]
   * @return {Object} The class instance
   */
  getValue() {
    return this.element.input.value;
  }
  /**
   * [setValue description]
   * @param {string} value [description]
   */
  setValue(value) {
    value = value || this.options.range[0];
    this.element.input.value = value;
    this.updateValue(value);
  }
  /**
   * [setLabel description]
   * @param {?} text [description]
   */
  setLabel(text) {
    text = text || this.options.label || this.options.text;
    if (text !== null && this.label) {
      this.label.textContent = text;
    }
  }
};
__publicField(_Slider, "defaults", {
  class: "slider",
  type: "control",
  label: null,
  checked: false,
  error: false,
  value: false,
  range: [0, 100],
  step: 5,
  modules: [control_default2, emitter_default],
  mixins: [],
  build: [
    "$root.material-slider",
    {},
    ["label$label.slider-label", {}],
    ["input$input"],
    [
      "$control.slider-control",
      {},
      [
        "$track.slider-track",
        {},
        ["canvas$canvas.slider-canvas", {}],
        ["$trackvalue.slider-track-value", {}],
        ["$knob.slider-knob", {}],
        [
          "$marker.slider-marker",
          {},
          ["$value.slider-value", {}]
        ]
      ]
    ]
  ],
  events: [
    ["element.input.focus", "focus"],
    ["element.input.blur", "blur"]
  ]
});
var Slider = _Slider;
var slider_default = Slider;

// ../node_modules/material/src/switch.js
var _Switch = class _Switch extends emitter_default2 {
  constructor(options2) {
    super();
    this.init(options2);
    this.build();
    this.setup();
    events_default.attach(this.options.events, this);
  }
  init(options2) {
    this.options = Object.assign({}, _Switch.defaults, options2 || {});
    Object.assign(this, build_default2, dataset_default);
    this.value = this.options.value;
  }
  setup() {
    this.styleAttributes();
    if (this.options.data) {
      dataset_default(this.element, this.options.data);
    }
    attributes_default(this.ui.input, this.options);
    if (this.options.checked) {
      this.check(true);
    }
    if (this.value) {
      this.element.input.setAttribute("checked", "checked");
    }
    if (this.options.tooltip) {
      this.element.setAttribute("data-tooltip", this.options.tooltip);
    }
    this.ui.input.setAttribute("aria-label", this.options.name);
    if (this.options.case) {
      this.element.classList.add(this.options.case + "-case");
    }
  }
  styleAttributes() {
    if (this.options.style) {
      this.element.classList.add("style-" + this.options.style);
    }
    if (this.options.size) {
      this.element.classList.add(this.options.size + "-size");
    }
    if (this.options.color) {
      this.element.classList.add("color-" + this.options.color);
    }
    if (this.options.bold) {
      this.element.classList.add("bold");
    }
  }
  set(prop, value, silent) {
    switch (prop) {
      case "value":
        this.setValue(value, silent);
        break;
      case "text":
        this.setValue(value);
        break;
      case "disabled":
        if (value === true) {
          this.disable();
        } else if (value === false) {
          this.enable();
        }
        break;
      default:
        this.setValue(prop, silent);
    }
    return this;
  }
  setLabel(value) {
    if (this.ui.label) {
      this.ui.label.innerHTML = value;
    }
  }
  setText(value) {
    this.setLabel(value);
  }
  get() {
    return this.value;
  }
  getValue() {
    return this.value;
  }
  setValue(value, silent) {
    this.check(value, silent);
  }
  toggle() {
    if (this.disabled)
      return;
    this.focus();
    if (this.checked) {
      this.check(false);
    } else {
      this.check(true);
    }
    return this;
  }
  check(checked, silent) {
    if (checked === true) {
      this.element.classList.add("is-checked");
      this.ui.input.checked = true;
      this.checked = true;
      this.value = true;
      if (!silent) {
        this.emit("change", this.checked);
      }
    } else {
      this.element.classList.remove("is-checked");
      this.ui.input.checked = false;
      this.checked = false;
      this.value = false;
      if (!silent) {
        this.emit("change", this.checked);
      }
    }
    return this;
  }
  focus() {
    if (this.disabled === true)
      return this;
    this.element.classList.add("is-focused");
    if (this.ui.input !== document.activeElement) {
      this.ui.input.focus();
    }
    return this;
  }
  blur() {
    this.element.classList.remove("is-focused");
    return this;
  }
};
__publicField(_Switch, "defaults", {
  class: "switch",
  attributes: ["type", "name", "required", "checked"],
  layout: [
    [element_default, "input", { class: "input", type: "checkbox" }],
    [
      element_default,
      "control",
      { class: "control" },
      [
        element_default,
        "track",
        { class: "track" },
        [element_default, "knob", { class: "knob" }]
      ]
    ]
  ],
  events: [
    ["ui.control.click", "toggle"],
    // ['ui.label.click', 'toggle'],
    // for accessibility purpose
    ["ui.input.click", "toggle"],
    ["ui.input.focus", "focus"],
    ["ui.input.blur", "blur"]
  ]
});
var Switch = _Switch;
var switch_default = Switch;

// ../node_modules/material/src/switcher.js
var _Switcher = class _Switcher extends emitter_default2 {
  constructor(options2) {
    super();
    this.init(options2);
    this.build();
    this.setup();
  }
  init(options2) {
    this.options = { ..._Switcher.defaults, ...options2 };
  }
  build() {
    this.element = document.createElement(this.options.tag);
    if (this.options.class !== "button") {
      this.element.setAttribute("class", "switcher " + this.options.class);
    } else {
      this.element.classList.add("switcher");
    }
    if (this.options.label) {
      this.label = document.createElement("label");
      this.label.innerHTML = this.options.label;
      this.element.appendChild(this.label);
    }
    this.knob = document.createElement("span");
    this.knob.classList.add("knob");
    this.element.appendChild(this.knob);
    if (this.options.size) {
      this.element.classList.add(this.options.size + "-size");
    }
    this.buildList(this.options.list);
    if (this.options.list) {
      this.addOptions(this.options.list);
    }
    if (this.options.container) {
      this.options.container.appendChild(this.element);
    }
  }
  buildList(list2) {
    this.list = document.createElement("ul");
    this.element.appendChild(this.list);
  }
  setup() {
    events_default.attach(this.options.events, this);
    if (this.options.default) {
      this.selectByName(this.options.default, true);
    }
  }
  click(event) {
    if (!event.target.dataset.switcher)
      return;
    this.select(event.target);
  }
  select(option) {
    if (this.options.mode === "multiple") {
      this.multiple(option);
    } else {
      this.unique(option);
    }
  }
  preselect(item) {
    if (item) {
      item.classList.add("preselected");
    } else {
      const items = this.list.childNodes;
      for (let i = 0; i < items.length; i++) {
        items[i].classList.remove("preselected");
      }
    }
  }
  selectByName(name) {
    const item = this.element.querySelector('[data-switcher="' + name + '"]');
    if (item) {
      this.select(item);
    }
  }
  preSelectByName(name) {
    const item = this.element.querySelector('[data-switcher="' + name + '"]');
    this.preselect(item);
  }
  unique(option) {
    if (!option.classList.contains("selected")) {
      const options2 = this.list.childNodes;
      for (let i = 0; i < options2.length; i++) {
        options2[i].classList.remove("selected");
      }
      option.classList.add("selected");
      this.selected = [option.dataset.switcher];
      this.emit("change", this.selected[0]);
    } else {
      if (this.options.allowEmpty) {
        option.classList.remove("selected");
        this.selected = [];
        this.emit("change", this.selected[0]);
      }
    }
  }
  multiple(option) {
    if (option.classList.contains("selected")) {
      if (this.selected.length === 1)
        return;
      const i = this.selected.indexOf(option.dataset.switcher);
      this.selected.splice(i, 1);
      option.classList.remove("selected");
    } else {
      option.classList.add("selected");
      this.selected.push(option.dataset.switcher);
    }
    this.emit("change", this.selected);
  }
  set(prop, value) {
    switch (prop) {
      case "value":
        this.setValue(value);
        break;
      case "options":
        this.setOptions(value);
        break;
      case "option":
        this.addOptions(value);
        break;
      default:
        this.setValue(prop);
    }
    return this;
  }
  setValue(value) {
    const list2 = this.options.list;
    if (this.options.mode === "unique") {
      for (var i = 0; i < list2.length; i++) {
        this.element.querySelector('[data-switcher="' + list2[i] + '"]').classList.remove("selected");
        if (list2[i] == value) {
          this.selected = [value];
          this.element.querySelector('[data-switcher="' + list2[i] + '"]').classList.add("selected");
        }
      }
    } else {
      value = value || [];
      this.selected = [];
      for (var i = 0; i < list2.length; i++) {
        this.element.querySelector('[data-switcher="' + list2[i] + '"]').classList.remove("selected");
        if (value.indexOf(list2[i]) !== -1) {
          this.selected.push(list2[i]);
          this.element.querySelector('[data-switcher="' + list2[i] + '"]').classList.add("selected");
        }
      }
    }
  }
  addOptions(list2) {
    if (!list2)
      return;
    for (let i = 0; i < list2.length; i++) {
      this.addOption(list2[i]);
    }
  }
  setOptions(list2) {
    if (!list2)
      return;
    if (this.options.list.length < 1)
      this.options.list = list2;
    for (let i = 0; i < list2.length; i++) {
      this.addOption(list2[i]);
    }
  }
  addOption(value) {
    const item = document.createElement("li");
    item.classList.add("item");
    item.dataset.switcher = value;
    item.innerHTML = value;
    this.list.appendChild(item);
  }
  setLabel(value) {
    if (this.label) {
      this.label.innerHTML = value;
    }
  }
  setText(value) {
    this.setLabel(value);
  }
  get() {
    if (this.options.mode === "unique") {
      return this.selected[0];
    } else {
      return this.selected;
    }
  }
};
__publicField(_Switcher, "defaults", {
  class: "switcher",
  tag: "div",
  list: [],
  first: false,
  mode: "unique",
  allowEmpty: false,
  events: [
    ["element.click", "click"]
  ]
});
var Switcher = _Switcher;
var switcher_default = Switcher;

// ../node_modules/material/src/module/mutation.js
var insertion = (element, callback) => {
  const observer3 = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node === element || node.contains(element)) {
          callback();
          observer3.disconnect();
        }
      });
    });
  });
  observer3.observe(document.body, { childList: true, subtree: true });
};

// ../node_modules/material/src/tabs.js
var Tabs = class extends control_default {
  constructor(options2) {
    super(options2);
    insertion(this.element, () => this.setup());
  }
  setup() {
    this.items = Array.from(this.element.childNodes).filter((node) => node.nodeType === Node.ELEMENT_NODE);
    this.item = {};
    this.items.forEach((item) => {
      this.item[item.name] = item;
      this.addListener(item);
    });
    this.indicator = document.createElement("div");
    this.indicator.classList.add("indicator");
    this.element.appendChild(this.indicator);
    if (this.options.show)
      this.show();
    if (this.options.selected && this.item[this.options.selected]) {
      this.select(this.options.selected, true);
    }
    this.emit("ready");
  }
  select(name, silent = false) {
    this.items.forEach((item) => {
      item.classList.toggle("selected", name === item.name);
    });
    this.selectedName = name;
    if (!silent)
      this.emit("select", name);
    this.updateIndicator(name);
  }
  updateIndicator(name) {
    name = name ?? this.selectedName;
    const item = this.item[name];
    if (!item)
      return;
    this.selected = item;
    const oElement = offset_default(this.element);
    const oItem = offset_default(item);
    const label = item.querySelector("label");
    const oLabel = label ? offset_default(label) : null;
    const width = (oLabel == null ? void 0 : oLabel.width) ?? this.options.indicator.size;
    const style = this.options.style === "secondary" ? `width: ${oItem.width}px; left: ${oItem.left - oElement.left}px;` : `width: ${width}px; left: ${oItem.left - oElement.left + oItem.width / 2 - width / 2}px;`;
    this.indicator.setAttribute("style", style);
  }
  addListener(item) {
    item.addEventListener("click", (ev) => {
      this.select(item.name);
    });
  }
};
__publicField(Tabs, "defaults", {
  class: "tabs",
  mixins: [display_default],
  show: true,
  style: "primary",
  indicator: {
    size: 30
  }
});
var tabs_default = Tabs;

// ../node_modules/material/src/element/observer.js
var observer = {
  insert: (element, cb) => {
    var observer3 = new MutationObserver((mutations) => {
      if (document.contains(element)) {
        if (typeof cb === "function" && !element.classList.contains("inserted")) {
          cb();
        }
        observer3.disconnect();
      }
    });
    observer3.observe(document, {
      attributes: false,
      childList: true,
      characterData: false,
      subtree: true
    });
  }
};
var observer_default = observer;

// ../node_modules/material/src/view/display.js
var display_default2 = {
  toggle() {
    this.visible ? this.hide() : this.show();
    this.emit("toggle");
    return this;
  },
  show() {
    this.element.getBoundingClientRect();
    this.element.classList.add("show");
    this.visible = true;
    if (this.underlay) {
      this.underlay.classList.add("show");
    }
    this.emit("show");
    return this;
  },
  hide() {
    if (!this.element)
      return;
    this.element.classList.remove("show");
    this.visible = false;
    if (this.underlay) {
      this.underlay.classList.remove("show");
    }
    this.emit("hide");
    return this;
  },
  destroy() {
    if (this.options.transition && this.element) {
      this.element.classList.remove("show");
      if (this.underlay) {
        this.underlay.classList.remove("show");
      }
      setTimeout(() => {
        this.removeChild();
      }, this.options.transition);
    } else {
      this.removeChild();
    }
    this.emit("destroy");
  },
  removeChild() {
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    }
    if (this.underlay && this.underlay.parentNode) {
      this.underlay.parentNode.removeChild(this.underlay);
    }
    this.emit("remove");
    return this;
  }
};

// ../node_modules/material/src/tabview.js
var _TabView = class _TabView extends emitter_default2 {
  constructor(options2) {
    super();
    this.init(options2);
    this.build();
    let ready = false;
    observer_default.insert(this.element, () => {
      if (!ready) {
        ready = true;
        this.setup();
        events_default.attach(this.options.events, this);
        this.emit("ready");
      }
    });
    return this;
  }
  init(options2) {
    this.options = { ..._TabView.defaults, ...options2 };
    Object.assign(this, build_default2, display_default2);
    this.ui = {};
  }
  setup() {
    this.view = {};
    this.views = [];
    this.ui.tabs = this.element.querySelector('[class="tabs"]');
    this.ui.view = this.element.querySelector('[class="views"]');
    this.ui.indicator = this.element.querySelector('[class="indicator"]');
    this.ui.buttons = this.ui.tabs.childNodes;
    this.ui.views = this.ui.view.childNodes;
    for (let i = 0; i < this.ui.views.length; i++) {
      if (this.ui.views[i].dataset) {
        this.views.push(this.ui.views[i].dataset.view);
        this.view[this.ui.views[i].dataset.view] = this.ui.views[i];
      }
    }
    this.hideView();
    this.click(this.ui.buttons[0]);
  }
  onTabClick(e2) {
    e2.stopPropagation();
    if (e2.target === e2.currentTarget)
      return;
    if (e2.target.matches("BUTTON")) {
      this.click(e2.target);
    }
  }
  select(view) {
    if (this.ui && this.ui.tabs) {
      const button = this.ui.tabs.querySelector('[data-view="' + view + '"]');
      if (button) {
        this.click(button);
      }
    } else {
      this.emit("notready");
    }
  }
  disable(view) {
    if (this.ui && this.ui.tabs) {
      const button = this.ui.tabs.querySelector('[data-view="' + view + '"]');
      if (button) {
        button.disabled = "disabled";
      }
    } else {
      this.emit("notready");
    }
  }
  enable(view) {
    if (this.ui && this.ui.tabs) {
      const button = this.ui.tabs.querySelector('[data-view="' + view + '"]');
      if (button) {
        button.disabled = false;
      }
    } else {
      this.emit("notready");
    }
  }
  hideView() {
    for (let i = 0; i < this.ui.views.length; i++) {
      this.ui.views[i].classList.add("hide");
    }
  }
  click(button) {
    const view = this.ui.view.querySelector('[data-view="' + button.dataset.view + '"]');
    this.hideView();
    if (this.button) {
      this.button.classList.remove("selected");
    }
    this.button = button;
    button.classList.add("selected");
    this.indicator(button);
    if (view) {
      view.classList.remove("hide");
    } else {
      console.log("view ", button.dataset.view, button, this.ui.views, " not found");
    }
    this.emit("select", button.dataset.view);
    return view;
  }
  indicator(button) {
    if (!this.ui.indicator)
      return;
    const tabs = this.ui.tabs.getBoundingClientRect();
    var button = button.getBoundingClientRect();
    this.ui.indicator.style.top = tabs.height - 2 + "px";
    this.ui.indicator.style.left = button.left - tabs.left + "px";
    this.ui.indicator.style.width = button.width + "px";
  }
};
__publicField(_TabView, "defaults", {
  base: "view",
  class: "tabview",
  mode: "style",
  events: [
    ["ui.tabs.click", "onTabClick"]
  ]
});
var TabView = _TabView;
var tabview_default = TabView;

// ../node_modules/material/src/textfield.js
var _Textfield = class _Textfield {
  static isComponent() {
    return true;
  }
  constructor(options2) {
    this.init(options2);
    this.build();
    events_default.attach(this.options.events, this);
  }
  init(options2) {
    this.options = { ..._Textfield.defaults, ...options2 };
    Object.assign(this, emitter_default, dataset_default);
  }
  build() {
    const tag = this.options.tag || "div";
    this.element = document.createElement(tag);
    this.element.classList.add("textfield");
    if (this.options.class !== "textfield") {
      this.element.classList.add(this.options.class);
    }
    this.buildLabel();
    this.buildInput();
    if (this.options.value) {
      this.set(this.options.value);
    }
    if (this.options.data) {
      dataset_default(this.element, this.options.data);
    }
    if (this.container) {
      this.container.appendChild(this.element);
    }
    return this;
  }
  buildLabel() {
    if (this.options.label) {
      this.label = document.createElement("label");
      this.label.classList.add("label");
      this.label.innerHTML = this.options.label;
      this.element.appendChild(this.label);
    }
  }
  buildInput() {
    let tag = "input";
    if (this.options.type === "multiline") {
      tag = "textarea";
    }
    this.input = document.createElement(tag);
    this.input.classList.add("input");
    this.element.appendChild(this.input);
    attributes_default(this.input, this.options);
    if (this.options.focus) {
      this.input.focus();
    }
  }
  onInput(ev) {
    this.emit("change", ev);
  }
  onFocus(ev) {
    this.element.classList.add("focused");
    this.emit("focus", ev);
  }
  onBlur(ev) {
    this.element.classList.remove("focused");
    this.emit("blur", ev);
  }
  onClick(ev) {
    this.emit("click", ev);
  }
  /**
   * Setter
   * @param {string} prop
   * @param {string} value
   * @return {Object} The class instance
   */
  set(prop, value) {
    switch (prop) {
      case "value":
        this.setValue(value);
        break;
      case "label":
        this.setLabel(value);
        break;
      default:
        this.setValue(prop);
    }
    return this;
  }
  setValue(value) {
    if (value && value !== "undefined") {
      this.value = value;
      this.input.value = value;
    } else {
      this.input.value = "";
    }
  }
  setLabel(value) {
    if (this.label) {
      this.label.innerHTML = value;
    }
  }
  setText(value) {
    this.setLabel(value);
    if (this.options.placeholder) {
      this.input.placeholder = value;
    }
  }
  hide() {
    this.element.classList.add("hide");
  }
  show() {
    this.element.classList.remove("hide");
  }
  get() {
    return this.input.value;
  }
};
__publicField(_Textfield, "defaults", {
  class: "textfield",
  attributes: ["type", "name", "title", "maxlength", "pattern", "min", "max", "placeholder", "readonly", "autocomplete", "required", "disabled"],
  events: [
    ["input.input", "onInput"],
    ["input.focus", "onFocus"],
    ["input.blur", "onBlur"],
    ["input.click", "onClick"]
  ]
});
var Textfield = _Textfield;
var textfield_default = Textfield;

// ../node_modules/material/src/mixin/create.js
function create3(options2) {
  const element = document.createElement(options2.tag || "div");
  classify_default(element, options2);
  return element;
}
var create_default2 = create3;

// ../node_modules/material/src/mixin/insert.js
var insert_default2 = {
  insert(container, context) {
    const element = this.element;
    this.insertElement(element, container, context);
    return this;
  },
  insertElement(element, container, context) {
    if (container && container.element) {
      container = container.element;
    }
    this.container = container;
    context = context || "bottom";
    const contexts = ["top", "bottom", "after", "before"];
    const methods = ["prepend", "append", "after", "before"];
    const index = contexts.indexOf(context);
    if (index === -1) {
      return;
    }
    const method = methods[index];
    dom_default[method](container, element);
    return element;
  }
};

// ../node_modules/material/src/toolbar.js
var _Toolbar = class _Toolbar {
  constructor(options2) {
    this.init(options2);
    this.build();
    this.attach();
  }
  init(options2) {
    this.options = { ..._Toolbar.defaults, ...options2 };
    Object.assign(this, insert_default2);
    this.waterfall = this.options.waterfall;
  }
  build() {
    this.element = create_default2(this.options);
    if (this.options.height) {
      this.element.style.height = this.options.height + "px";
    }
    if (this.options.fixed) {
      this.element.classList.add("is-fixed");
    }
    if (this.options.flexible) {
      this.element.classList.add("is-flexible");
    }
    return this;
  }
  attach() {
    this.element.addEventListener("DOMNodeInserted", (e2) => {
      const textNode = e2.target;
      if (textNode !== this.element)
        return;
      const size = this.size = offset_default(this.element, "height");
      const view = this.view = this.element.parentNode;
      let padding = window.getComputedStyle(view)["padding-top"];
      padding = parseInt(padding, 10);
      this.padding = padding;
      const ptop = this.ptop = size + padding;
      if (document.body == view) {
        this.element.classList.add("toolbar-body");
      }
      this.scroll(view);
    });
  }
  /**
   * Setter
   * @param {string} prop
   * @param {string} value
   * @return {Object} The class instance
   */
  set(prop, value) {
    switch (prop) {
      case "minimize":
        this.element.setAttribute("style", "height: 64px");
        break;
      case "value":
        this.setValue(value);
        break;
      case "label":
        this.setLabel(value);
        break;
      default:
        this.check(prop);
    }
    return this;
  }
  scroll(view) {
    let isBody = false;
    let element = view;
    this.scrolling = view;
    if (view === document.body) {
      isBody = true;
      element = document;
      this.scrolling = document.body;
    }
    view.classList.add();
    element.addEventListener("scroll", (e2) => {
      let scrollTop;
      if (isBody) {
        scrollTop = (document.documentElement || document.body.parentNode || document.body).scrollTop;
      } else {
        scrollTop = view.scrollTop;
      }
      if (scrollTop > 0) {
        this.element.classList.add("is-scrolled");
      } else {
        this.element.classList.remove("is-scrolled");
      }
      this.update(e2, scrollTop);
    });
  }
  update(e2, scrollTop) {
    if (this.options.fixed) {
      this.fixed(e2, scrollTop);
    }
    if (this.options.flexible) {
      this.flexible(e2, scrollTop);
    }
  }
  flexible(e2, scrollTop) {
    const size = offset_default(this.element, "height");
    let height = "64";
    if (size < height) {
      this.element.style.height = height + "px";
    } else {
      height = this.size - scrollTop;
      if (height < 64)
        height = 64;
      this.element.style.height = height + "px";
    }
  }
  fixed(e2, scrollTop) {
    if (scrollTop > 0) {
      this.element.style.transform = "translateY(" + scrollTop + "px)";
    } else {
      this.element.style.transform = "translateY(" + scrollTop + "px)";
    }
  }
  waterfall$(e2) {
  }
};
__publicField(_Toolbar, "defaults", {
  prefix: "material",
  class: "toolbar",
  tag: "div"
});
var Toolbar = _Toolbar;
var toolbar_default = Toolbar;

// ../node_modules/material/src/module/touch.js
var touch_default = () => {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e2) {
    return false;
  }
};

// ../node_modules/material/src/tooltip.js
var Tooltip = class extends component_default {
  bindTargets() {
    const targets = document.querySelectorAll(this.options.targets);
    for (let i = 0; i < targets.length; i++) {
      targets[i].addEventListener("mouseover", (e2) => {
        if (touch_default())
          return;
        if (this.disabled === true) {
          this.hide();
          return;
        }
        if (e2.currentTarget.classList.contains("selected")) {
          this.hide();
          return;
        }
        this.ui.label.innerHTML = e2.currentTarget.dataset.tooltip;
        const coord = this.offset(e2.currentTarget);
        this.show();
        this.position(e2.currentTarget);
      });
      targets[i].addEventListener("mouseleave", (e2) => {
        this.ui.label.innerHTML = "";
        this.hide();
      });
    }
    this.element.addEventListener("click", (e2) => {
      e2.preventDefault();
      e2.stop();
      this.hide();
    });
  }
  offset(target) {
    const rect = target.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    return { top: rect.top + scrollTop, left: rect.left + scrollLeft };
  }
  hide() {
    this.element.classList.remove("show");
  }
  show() {
    this.element.classList.add("show");
  }
  disable() {
    this.hide();
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
};
__publicField(Tooltip, "defaults", {
  base: "component",
  class: "tooltip",
  tag: "span",
  mixins: [position_default],
  targets: "[data-tooltip]",
  offset: {
    top: 60
  },
  position: {
    align: "center",
    vAlign: "bottom"
  },
  disabled: false,
  layout: [
    [element_default, { tag: "span", class: "pointer" }],
    [element_default, "label", { tag: "span", class: "label" }]
  ]
});
var tooltip_default = Tooltip;

// ../node_modules/material/src/view.js
var View = class extends control_default {
};
__publicField(View, "defaults", {
  class: "view"
});
var view_default = View;

// ../node_modules/material/src/module/clone.js
var deepClone = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  const clone = Array.isArray(obj) ? [] : {};
  Object.entries(obj).forEach(([key, value]) => {
    clone[key] = deepClone(value);
  });
  return clone;
};
var clone_default = deepClone;

// ../node_modules/material/src/module/device.js
var previousDevice = window.device;
var device = {};
var os = ["ios", "iphone", "ipad", "ipod", "android", "blackberry", "macos", "windows", "fxos", "meego", "television"];
var type = ["mobile", "tablet", "desktop"];
var television = ["googletv", "viera", "smarttv", "internet.tv", "netcast", "nettv", "appletv", "boxee", "kylo", "roku", "dlnadoc", "pov_tv", "hbbtv", "ce-html"];
var changeOrientationList = [];
window.device = device;
var documentElement = window.document.documentElement;
var userAgent = window.navigator.userAgent.toLowerCase();
device.macos = function() {
  return find("mac");
};
device.ios = function() {
  return device.iphone() || device.ipod() || device.ipad();
};
device.iphone = function() {
  return !device.windows() && find("iphone");
};
device.ipod = function() {
  return find("ipod");
};
device.ipad = function() {
  const iPadOS13Up = navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  return find("ipad") || iPadOS13Up;
};
device.android = function() {
  return !device.windows() && find("android");
};
device.androidPhone = function() {
  return device.android() && find("mobile");
};
device.androidTablet = function() {
  return device.android() && !find("mobile");
};
device.blackberry = function() {
  return find("blackberry") || find("bb10");
};
device.blackberryPhone = function() {
  return device.blackberry() && !find("tablet");
};
device.blackberryTablet = function() {
  return device.blackberry() && find("tablet");
};
device.windows = function() {
  return find("windows");
};
device.windowsPhone = function() {
  return device.windows() && find("phone");
};
device.windowsTablet = function() {
  return device.windows() && (find("touch") && !device.windowsPhone());
};
device.fxos = function() {
  return (find("(mobile") || find("(tablet")) && find(" rv:");
};
device.fxosPhone = function() {
  return device.fxos() && find("mobile");
};
device.fxosTablet = function() {
  return device.fxos() && find("tablet");
};
device.meego = function() {
  return find("meego");
};
device.cordova = function() {
  return window.cordova && location.protocol === "file:";
};
device.nodeWebkit = function() {
  return typeof window.process === "object";
};
device.mobile = function() {
  return device.androidPhone() || device.iphone() || device.ipod() || device.windowsPhone() || device.blackberryPhone() || device.fxosPhone() || device.meego();
};
device.tablet = function() {
  return device.ipad() || device.androidTablet() || device.blackberryTablet() || device.windowsTablet() || device.fxosTablet();
};
device.desktop = function() {
  return !device.tablet() && !device.mobile();
};
device.television = function() {
  let i = 0;
  while (i < television.length) {
    if (find(television[i])) {
      return true;
    }
    i++;
  }
  return false;
};
device.portrait = function() {
  if (screen.orientation && Object.prototype.hasOwnProperty.call(window, "onorientationchange")) {
    return includes(screen.orientation.type, "portrait");
  }
  if (device.ios() && Object.prototype.hasOwnProperty.call(window, "orientation")) {
    return Math.abs(window.orientation) !== 90;
  }
  return window.innerHeight / window.innerWidth > 1;
};
device.landscape = function() {
  if (screen.orientation && Object.prototype.hasOwnProperty.call(window, "onorientationchange")) {
    return includes(screen.orientation.type, "landscape");
  }
  if (device.ios() && Object.prototype.hasOwnProperty.call(window, "orientation")) {
    return Math.abs(window.orientation) === 90;
  }
  return window.innerHeight / window.innerWidth < 1;
};
device.noConflict = function() {
  window.device = previousDevice;
  return this;
};
function includes(haystack, needle) {
  return haystack.indexOf(needle) !== -1;
}
function find(needle) {
  return includes(userAgent, needle);
}
function hasClass(className) {
  return documentElement.className.match(new RegExp(className, "i"));
}
function addClass(className) {
  let currentClassNames = null;
  if (!hasClass(className)) {
    currentClassNames = documentElement.className.replace(/^\s+|\s+$/g, "");
    documentElement.className = `${currentClassNames} ${className}`;
  }
}
function removeClass(className) {
  if (hasClass(className)) {
    documentElement.className = documentElement.className.replace(
      ` ${className}`,
      ""
    );
  }
}
function cleanClasses() {
  const classes = [...os, ...type];
  for (let i = 0; i < classes.length; i++) {
    removeClass(classes[i]);
  }
}
function applyClass() {
  cleanClasses();
  if (device.ios()) {
    if (device.ipad()) {
      addClass("ios ipad tablet");
    } else if (device.iphone()) {
      addClass("ios iphone mobile");
    } else if (device.ipod()) {
      addClass("ios ipod mobile");
    }
  } else if (device.macos()) {
    addClass("macos desktop");
  } else if (device.android()) {
    if (device.androidTablet()) {
      addClass("android tablet");
    } else {
      addClass("android mobile");
    }
  } else if (device.blackberry()) {
    if (device.blackberryTablet()) {
      addClass("blackberry tablet");
    } else {
      addClass("blackberry mobile");
    }
  } else if (device.windows()) {
    if (device.windowsTablet()) {
      addClass("windows tablet");
    } else if (device.windowsPhone()) {
      addClass("windows mobile");
    } else {
      addClass("windows desktop");
    }
  } else if (device.fxos()) {
    if (device.fxosTablet()) {
      addClass("fxos tablet");
    } else {
      addClass("fxos mobile");
    }
  } else if (device.meego()) {
    addClass("meego mobile");
  } else if (device.nodeWebkit()) {
    addClass("node-webkit");
  } else if (device.television()) {
    addClass("television");
  } else if (device.desktop()) {
    addClass("desktop");
  }
  if (device.cordova()) {
    addClass("cordova");
  }
}
applyClass();
function handleOrientation() {
  if (device.landscape()) {
    removeClass("portrait");
    addClass("landscape");
    walkOnChangeOrientationList("landscape");
  } else {
    removeClass("landscape");
    addClass("portrait");
    walkOnChangeOrientationList("portrait");
  }
  setOrientationCache();
}
function walkOnChangeOrientationList(newOrientation) {
  for (let index = 0; index < changeOrientationList.length; index++) {
    changeOrientationList[index](newOrientation);
  }
}
device.onChangeOrientation = function(cb) {
  if (typeof cb === "function") {
    changeOrientationList.push(cb);
  }
};
var orientationEvent = "resize";
if (Object.prototype.hasOwnProperty.call(window, "onorientationchange")) {
  orientationEvent = "orientationchange";
}
if (window.addEventListener) {
  window.addEventListener(orientationEvent, handleOrientation, false);
} else if (window.attachEvent) {
  window.attachEvent(orientationEvent, handleOrientation);
} else {
  window[orientationEvent] = handleOrientation;
}
handleOrientation();
function findMatch(arr) {
  for (let i = 0; i < arr.length; i++) {
    if (device[arr[i]]()) {
      return arr[i];
    }
  }
  return "unknown";
}
device.type = findMatch(type);
device.os = findMatch(os);
function setOrientationCache() {
  device.orientation = findMatch(["portrait", "landscape"]);
}
setOrientationCache();
var previousDeviceType = null;
device.onDeviceChange = null;
function updateDeviceDetection() {
  userAgent = window.navigator.userAgent.toLowerCase();
  device.type = findMatch(type);
  device.os = findMatch(os);
  setOrientationCache();
  applyClass();
  checkAndHandleDeviceChange();
}
window.addEventListener("resize", updateDeviceDetection);
function triggerOnDeviceChange() {
  if (typeof device.onDeviceChange === "function") {
    device.onDeviceChange(device.type);
  }
}
function checkAndHandleDeviceChange() {
  const currentDeviceType = device.type;
  if (previousDeviceType !== currentDeviceType) {
    triggerOnDeviceChange();
    previousDeviceType = currentDeviceType;
  }
}
var device_default = device;

// ../node_modules/material/src/module/jsontohtml.js
function jsonToHTML(obj) {
  let html = "<div>";
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === "object" && value !== null) {
      html += `<div class="${key}">${key}${jsonToHTML(value)}</div>`;
    } else if (Array.isArray(value)) {
      html += `<div class="${key}">${key}<ul>${value.map((item) => `<li>${item}</li>`).join("")}</ul></div>`;
    } else {
      html += `<p>${key}: ${value || "N/A"}</p>`;
    }
  }
  html += "</div>";
  return html;
}

// ../node_modules/material/src/module/mediator.js
var mediator = /* @__PURE__ */ (() => {
  const subscribe = function(store, fn) {
    if (!mediator.stores[store]) {
      mediator.stores[store] = [];
    }
    mediator.stores[store].push({
      context: this,
      callback: fn
    });
    return this;
  };
  const unsubscribe = function(store, fn) {
    if (!mediator.stores[store]) {
      return this;
    }
    mediator.stores[store] = mediator.stores[store].filter((subscription) => subscription.callback !== fn);
    return this;
  };
  const publish = function(store, ...args) {
    if (!mediator.stores[store]) {
      return false;
    }
    for (const value of mediator.stores[store]) {
      const subscription = value;
      subscription.callback.apply(subscription.context, args);
    }
    return this;
  };
  return {
    stores: {},
    publish,
    subscribe,
    unsubscribe,
    installTo: function(obj) {
      obj.subscribe = subscribe;
      obj.publish = publish;
    },
    init: function(obj) {
      obj.subscribe = subscribe;
      obj.publish = publish;
    }
  };
})();
var mediator_default = mediator;

// ../node_modules/material/src/module/merge.js
var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
var merge = (target, ...sources) => {
  sources.forEach((source) => {
    if (isObject2(source)) {
      Object.keys(source).forEach((key) => {
        const sourceValue = source[key];
        if (isObject2(sourceValue)) {
          if (!isObject2(target[key]))
            target[key] = {};
          merge(target[key], sourceValue);
        } else {
          target[key] = sourceValue;
        }
      });
    }
  });
  return target;
};
var merge_default = merge;

// ../node_modules/material/src/module/observer.js
var observer2 = /* @__PURE__ */ (() => {
  const watch = function(event, fn, context = this) {
    if (typeof event !== "string" || typeof fn !== "function") {
      throw new Error("Invalid arguments. Event must be a string and callback must be a function.");
    }
    if (!observer2.events[event]) {
      observer2.events[event] = [];
    }
    observer2.events[event].push({
      context,
      callback: fn
    });
    return this;
  };
  const unwatch = function(event, fn) {
    if (!observer2.events[event])
      return this;
    observer2.events[event] = observer2.events[event].filter((subscriber) => subscriber.callback !== fn);
    return this;
  };
  const notify = function(event, ...args) {
    if (!this.events[event])
      return this;
    for (const { context, callback } of this.events[event]) {
      callback.apply(context, args);
    }
    return this;
  };
  return {
    events: {},
    watch,
    unwatch,
    notify,
    init: function(obj) {
      obj.watch = watch;
      obj.unwatch = unwatch;
      obj.notify = notify;
    }
  };
})();
var observer_default2 = observer2;

// ../node_modules/material/src/module/request.js
var request = async (url, method = "GET", body = null, headers = {}, signal = null, debug = false) => {
  const defaultHeaders = {
    Accept: "application/json",
    "Content-Type": "application/json"
  };
  const options2 = {
    method,
    headers: { ...defaultHeaders, ...headers },
    signal
  };
  if (debug) {
    console.log("debug", options2);
  }
  if (body) {
    options2.body = JSON.stringify(body);
  }
  try {
    const response = await fetch(url, options2);
    if (!response.ok) {
    }
    if (headers.Accept === "text/xml") {
      return await response.text();
    } else {
      return await response.json();
    }
  } catch (error) {
    if (headers.Accept === "text/xml") {
      throw error;
    } else {
      throw { error };
    }
  }
};
var request_default = request;

// ../node_modules/material/src/module/ripple.js
var defaults = {
  // transition: '.375s cubic-bezier(0.4, 0.0, 0.2, 1)',
  transition: ".375s linear",
  opacity: ["1", ".3"]
};
var init3 = (container) => {
  container.addEventListener("mousedown", (e2) => {
    show(e2);
  });
};
var show = (e2) => {
  const container = e2.target;
  const offs = offset_default(container);
  const ripple = document.createElement("div");
  ripple.classList.add("ripple");
  const end = coordinate(offs);
  const initial = {
    left: `${e2.offsetX || offs.width / 2}px`,
    top: `${e2.offsetY || offs.height / 2}px`
  };
  ripple.style.left = initial.left;
  ripple.style.top = initial.top;
  ripple.style.transition = defaults.transition;
  insert_default(ripple, container, "top");
  setTimeout(() => {
    ripple.style.left = end.left;
    ripple.style.top = end.top;
    ripple.style.width = end.size;
    ripple.style.height = end.size;
  }, 1);
  document.body.onmouseup = () => {
    destroy2(ripple);
  };
};
var coordinate = (o) => {
  let size = o.height;
  let top = -o.height / 2;
  if (o.width > o.height) {
    top = -(o.width - o.height / 2);
    size = o.width;
  }
  return {
    size: `${size * 2}px`,
    top: `${top}px`,
    left: `${size / -2}px`
  };
};
var destroy2 = (ripple) => {
  if (ripple.parentNode)
    ripple.style.opacity = "0";
  document.body.onmouseup = null;
  setTimeout(() => {
    if (ripple.parentNode)
      ripple.parentNode.removeChild(ripple);
  }, 1e3);
};
var ripple_default = init3;

// ../node_modules/material/src/module/smoothscroll.js
var smoothscroll = (e2, top, time = 275) => {
  const start = top - e2.scrollTop;
  const step = start / 100;
  let current = 0;
  while (current <= time) {
    window.setTimeout(scrolling, current, e2, step);
    current += time / 100;
  }
};
var scrolling = (e2, step) => {
  e2.scrollBy(0, step);
};
var smoothscroll_default = smoothscroll;
export {
  appbar_default as AppBar,
  button_default as Button,
  card_default as Card,
  checkbox_default as Checkbox,
  component_default as Component,
  control_default as Control,
  datehour_default as DateHour,
  dialog_default as Dialog,
  drawer_default as Drawer,
  element_default as Element,
  emitter_default2 as EventEmitter,
  file_default as File,
  form_default as Form,
  image_default as Image,
  list_default as List,
  loading_default as Loading,
  menu_default as Menu,
  navigation_default as Navigation,
  progress_default as Progress,
  select_default as Select,
  selecter_default as Selecter,
  slider_default as Slider,
  snackbar_default as Snackbar,
  switch_default as Switch,
  switcher_default as Switcher,
  tabview_default as TabView,
  tabs_default as Tabs,
  text_default as Text,
  textfield_default as Textfield,
  toolbar_default as Toolbar,
  tooltip_default as Tooltip,
  view_default as View,
  attributes_default as attributes,
  build_default2 as build,
  clone_default as clone,
  create,
  dataset_default as dataset,
  device_default as device,
  display_default as display,
  emitter_default as emitter,
  events_default as events,
  jsonToHTML,
  mediator_default as mediator,
  merge_default as merge,
  observer_default2 as observer,
  position_default as position,
  request_default as request,
  ripple_default as ripple,
  smoothscroll_default as smoothscroll,
  touch_default as touch
};
//# sourceMappingURL=material.js.map
